<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>法算day5</title>
      <link href="/lief/%E6%B3%95%E7%AE%97day5/"/>
      <url>/lief/%E6%B3%95%E7%AE%97day5/</url>
      
        <content type="html"><![CDATA[<h1 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h1><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。<br>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br>返回容器可以储存的最大水量。<br>✅ 说明：你不能倾斜容器。</p><h4 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h4><p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg"><br>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49<br>解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><p>示例 2：<br>输入：height &#x3D; [1,1]<br>输出：1</p><p>提示：<br>n &#x3D;&#x3D; height.length<br>2 &lt;&#x3D; n &lt;&#x3D; 105<br>0 &lt;&#x3D; height[i] &lt;&#x3D; 104</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>这个问题是要找到两条垂直线，使得它们与x轴构成的容器能容纳最多的水。容器的容量由两个因素决定：<br>宽度：两条线之间的水平距离<br>高度：两条线中较短的那条线的高度<br>所以容量公式为：容量 &#x3D; 距离 × min(左线高度, 右线高度)</p><h3 id="为什么移动较短的线？"><a href="#为什么移动较短的线？" class="headerlink" title="为什么移动较短的线？"></a>为什么移动较短的线？</h3><p>这是算法的关键点：<br>容器的容量由较短边的高度决定<br>每次移动指针，宽度都会减小<br>如果移动较长的边，容量只会更小（因为高度不会增加，宽度减小）<br>如果移动较短的边，有可能找到更高的边，从而增加容量</p><h3 id="java版（双指针法）"><a href="#java版（双指针法）" class="headerlink" title="java版（双指针法）"></a>java版（双指针法）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class ContainerWithMostWater &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 测试用例1</span><br><span class="line">        int[] height1 = &#123;1,8,6,2,5,4,8,3,7&#125;;</span><br><span class="line">        System.out.println(&quot;测试1结果: &quot; + maxArea(height1)); // 应该输出49</span><br><span class="line">        </span><br><span class="line">        // 测试用例2</span><br><span class="line">        int[] height2 = &#123;1,1&#125;;</span><br><span class="line">        System.out.println(&quot;测试2结果: &quot; + maxArea(height2)); // 应该输出1</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static int maxArea(int[] height) &#123;</span><br><span class="line">        // 初始化左右指针，分别指向数组的首尾</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = height.length - 1;</span><br><span class="line">        // 记录最大面积</span><br><span class="line">        int maxArea = 0;</span><br><span class="line">        </span><br><span class="line">        // 当左右指针没有相遇时，继续循环</span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            // 计算当前两条线之间的宽度</span><br><span class="line">            int width = right - left;</span><br><span class="line">            // 容器的高度取决于较短的那条线</span><br><span class="line">            int currentHeight = Math.min(height[left], height[right]);</span><br><span class="line">            // 计算当前面积</span><br><span class="line">            int currentArea = width * currentHeight;</span><br><span class="line">            // 更新最大面积</span><br><span class="line">            maxArea = Math.max(maxArea, currentArea);</span><br><span class="line">            </span><br><span class="line">            // 关键步骤：移动较短的那条线对应的指针</span><br><span class="line">            // 因为移动较长的线不会增加容量，而移动较短的线有可能找到更高的线</span><br><span class="line">            if (height[left] &lt; height[right]) &#123;</span><br><span class="line">                left++;  // 左指针右移</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                right--; // 右指针左移</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ 说明：</p><ol><li>时间复杂度：O(n) - 我们只需要遍历数组一次</li><li>空间复杂度：O(1) - 只使用了常数级别的额外空间</li></ol><h3 id="python版"><a href="#python版" class="headerlink" title="python版"></a>python版</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">def maxArea(height):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    计算容器能容纳的最大水量</span><br><span class="line">    使用双指针法，从数组的两端向中间移动</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 初始化左指针和右指针</span><br><span class="line">    left = 0</span><br><span class="line">    right = len(height) - 1</span><br><span class="line">    # 初始化最大面积</span><br><span class="line">    max_area = 0</span><br><span class="line">    </span><br><span class="line">    # 当左指针小于右指针时循环</span><br><span class="line">    while left &lt; right:</span><br><span class="line">        # 计算当前左右指针构成的容器的面积</span><br><span class="line">        # 面积 = 宽度 * 高度，高度取左右指针中较小的那个</span><br><span class="line">        current_area = (right - left) * min(height[left], height[right])</span><br><span class="line">        # 更新最大面积</span><br><span class="line">        max_area = max(max_area, current_area)</span><br><span class="line">        </span><br><span class="line">        # 移动高度较小的指针，因为移动高度较大的指针不会增加面积</span><br><span class="line">        if height[left] &lt; height[right]:</span><br><span class="line">            left += 1  # 左指针右移</span><br><span class="line">        else:</span><br><span class="line">            right -= 1  # 右指针左移</span><br><span class="line">    </span><br><span class="line">    return max_area</span><br><span class="line"></span><br><span class="line"># 测试代码</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    # 示例1</span><br><span class="line">    height1 = [1,8,6,2,5,4,8,3,7]</span><br><span class="line">    print(maxArea(height1))  # 输出: 49</span><br><span class="line">    </span><br><span class="line">    # 示例2</span><br><span class="line">    height2 = [1,1]</span><br><span class="line">    print(maxArea(height2))  # 输出: 1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>法算day4</title>
      <link href="/lief/%E6%B3%95%E7%AE%97day4/"/>
      <url>/lief/%E6%B3%95%E7%AE%97day4/</url>
      
        <content type="html"><![CDATA[<h1 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a>移动零</h1><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意 ：必须在不复制数组的情况下原地对数组进行操作。</strong></p><p>示例 1:<br>输入: nums &#x3D; [0,1,0,3,12]<br>输出: [1,3,12,0,0]</p><p>示例 2:<br>输入: nums &#x3D; [0]<br>输出: [0]</p><p>提示:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 104<br>-231 &lt;&#x3D; nums[i] &lt;&#x3D; 231 - 1</p><h3 id="java版"><a href="#java版" class="headerlink" title="java版"></a>java版</h3><h4 id="方法一：双指针法"><a href="#方法一：双指针法" class="headerlink" title="方法一：双指针法"></a>方法一：双指针法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void moveZeroes(int[] nums) &#123;</span><br><span class="line">        // 边界情况检查：如果数组为空或长度为0，直接返回</span><br><span class="line">        if (nums == null || nums.length == 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 使用双指针法</span><br><span class="line">        // left指针：指向当前应该放置非零元素的位置</span><br><span class="line">        int left = 0;</span><br><span class="line">        </span><br><span class="line">        // 遍历数组</span><br><span class="line">        for (int right = 0; right &lt; nums.length; right++) &#123;</span><br><span class="line">            // 如果当前元素不为0</span><br><span class="line">            if (nums[right] != 0) &#123;</span><br><span class="line">                // 将非零元素移动到left指针的位置</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                // 如果left和right不是同一个位置，说明移动了元素    </span><br><span class="line">                // 需要将原位置设置为0（避免重复）                        </span><br><span class="line">                if (left != right) &#123;</span><br><span class="line">                    nums[right] = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                // left指针向右移动，准备放置下一个非零元素</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果当前元素为0，left指针不动，right指针继续向右移动</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ 说明：</p><ol><li>left 指针：记录下一个非零元素应该放置的位置<br>right 指针：遍历整个数组，寻找非零元素</li><li>时间复杂度：O(n)，只需要遍历数组一次（或两次）</li><li>空间复杂度：O(1)，只使用了常数级别的额外空间</li></ol><h2 id="额外补充-增强for循环有一个严重缺陷！"><a href="#额外补充-增强for循环有一个严重缺陷！" class="headerlink" title="额外补充-增强for循环有一个严重缺陷！"></a>额外补充-增强for循环有一个严重缺陷！</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int[] nums = &#123;0, 1, 0, 3, 12&#125;;</span><br><span class="line"></span><br><span class="line">// 使用增强for循环（有问题！）</span><br><span class="line">for (int num : nums) &#123;</span><br><span class="line">    if (num != 0) &#123;</span><br><span class="line">        nums[insertPos] = num;  // 这里会修改数组！</span><br><span class="line">        insertPos++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">初始: [0, 1, 0, 3, 12]</span><br><span class="line">第1次循环: num=0 → 跳过</span><br><span class="line">第2次循环: num=1 → nums[0]=1 → 数组变成 [1, 1, 0, 3, 12]</span><br><span class="line">第3次循环: num=0 → 跳过</span><br><span class="line">第4次循环: num=3 → nums[1]=3 → 数组变成 [1, 3, 0, 3, 12]</span><br><span class="line">第5次循环: num=12 → nums[2]=12 → 数组变成 [1, 3, 12, 3, 12]</span><br></pre></td></tr></table></figure><p>增强for循环适合只读操作，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 只读操作 - 适合用增强for循环</span><br><span class="line">int sum = 0;</span><br><span class="line">for (int num : nums) &#123;</span><br><span class="line">    sum += num;  // 不修改数组，只是读取值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 或者打印数组</span><br><span class="line">for (int num : nums) &#123;</span><br><span class="line">    System.out.print(num + &quot; &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ 总结：<br>增强for循环：语法简洁，适合只读遍历<br>传统for循环：功能更强大，可以通过索引修改数组，控制遍历过程</p><h3 id="python版"><a href="#python版" class="headerlink" title="python版"></a>python版</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">def moveZeroes(nums):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    将数组中的所有0移动到末尾，保持非零元素的相对顺序</span><br><span class="line">    </span><br><span class="line">    参数:</span><br><span class="line">    nums: List[int] - 输入的整数列表</span><br><span class="line">    </span><br><span class="line">    思路:</span><br><span class="line">    使用双指针，left指针记录非零元素应该放置的位置</span><br><span class="line">    right指针遍历整个数组</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    left = 0  # left指针：指向下一个非零元素应该放置的位置</span><br><span class="line">    </span><br><span class="line">    # right指针遍历整个数组</span><br><span class="line">    for right in range(len(nums)):</span><br><span class="line">        # 如果当前元素不为0</span><br><span class="line">        if nums[right] != 0:</span><br><span class="line">            # 将非零元素交换到left位置</span><br><span class="line">            nums[left], nums[right] = nums[right], nums[left]</span><br><span class="line">            # left指针向右移动，准备放置下一个非零元素</span><br><span class="line">            left += 1</span><br><span class="line">        # 如果当前元素为0，left指针不动，right指针继续移动</span><br></pre></td></tr></table></figure><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 测试函数</span><br><span class="line">def test_moveZeroes():</span><br><span class="line">    # 测试用例1</span><br><span class="line">    nums1 = [0, 1, 0, 3, 12]</span><br><span class="line">    moveZeroes(nums1)</span><br><span class="line">    print(f&quot;测试1: &#123;nums1&#125;&quot;)  # 应该输出 [1, 3, 12, 0, 0]</span><br><span class="line">    </span><br><span class="line">    # 测试用例2</span><br><span class="line">    nums2 = [0]</span><br><span class="line">    moveZeroes(nums2)</span><br><span class="line">    print(f&quot;测试2: &#123;nums2&#125;&quot;)  # 应该输出 [0]</span><br><span class="line">    </span><br><span class="line">    # 测试用例3</span><br><span class="line">    nums3 = [1, 2, 3, 4, 5]</span><br><span class="line">    moveZeroes(nums3)</span><br><span class="line">    print(f&quot;测试3: &#123;nums3&#125;&quot;)  # 应该输出 [1, 2, 3, 4, 5]</span><br><span class="line">    </span><br><span class="line">    # 测试用例4</span><br><span class="line">    nums4 = [0, 0, 0, 1, 2]</span><br><span class="line">    moveZeroes(nums4)</span><br><span class="line">    print(f&quot;测试4: &#123;nums4&#125;&quot;)  # 应该输出 [1, 2, 0, 0, 0]</span><br><span class="line"></span><br><span class="line"># 运行测试</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    test_moveZeroes()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>法算day3</title>
      <link href="/lief/%E6%B3%95%E7%AE%97day3/"/>
      <url>/lief/%E6%B3%95%E7%AE%97day3/</url>
      
        <content type="html"><![CDATA[<h1 id="最长序列"><a href="#最长序列" class="headerlink" title="最长序列"></a>最长序列</h1><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。<br>请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p><p>示例 1：<br>输入：nums &#x3D; [100,4,200,1,3,2]<br>输出：4<br>解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</p><p>示例 2：<br>输入：nums &#x3D; [0,3,7,2,5,8,4,6,0,1]<br>输出：9</p><p>示例 3：<br>输入：nums &#x3D; [1,0,1,2]<br>输出：3</p><p>提示：<br>0 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109</p><h3 id="tip"><a href="#tip" class="headerlink" title="tip"></a>tip</h3><table><thead><tr><th align="center">特性</th><th align="center">HashSet<Integer></th><th align="center">HashMap&lt;Integer, Integer&gt;</th></tr></thead><tbody><tr><td align="center">本质</td><td align="center">只存“值”的集合</td><td align="center">存“键值对”的映射表</td></tr><tr><td align="center">泛型参数</td><td align="center"><E>（元素类型）</td><td align="center">&lt;K, V&gt;（键类型，值类型）</td></tr><tr><td align="center">能否重复</td><td align="center">元素不能重复</td><td align="center">键不能重复，值可以重复</td></tr><tr><td align="center">查询方式</td><td align="center">contains(value) 判断值是否存在</td><td align="center">get(key) 用键取值</td></tr><tr><td align="center">常用方法</td><td align="center">add(e)、remove(e)、contains(e)</td><td align="center">put(k,v)、get(k)、remove(k)</td></tr></tbody></table><h3 id="java版"><a href="#java版" class="headerlink" title="java版"></a>java版</h3><h4 id="方法一：先把所有数字放进“快速查找表”HashSet，然后只从每个“序列开头”往后数，数完更新最长值，保证每个数字最多被看两遍，时间复杂度就是-O-n-。"><a href="#方法一：先把所有数字放进“快速查找表”HashSet，然后只从每个“序列开头”往后数，数完更新最长值，保证每个数字最多被看两遍，时间复杂度就是-O-n-。" class="headerlink" title="方法一：先把所有数字放进“快速查找表”HashSet，然后只从每个“序列开头”往后数，数完更新最长值，保证每个数字最多被看两遍，时间复杂度就是 O(n)。"></a>方法一：先把所有数字放进“快速查找表”HashSet，然后只从每个“序列开头”往后数，数完更新最长值，保证每个数字最多被看两遍，时间复杂度就是 O(n)。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public int longestConsecutive(int[] nums) &#123;</span><br><span class="line">        // 如果数组是空的，直接返回 0，啥也不用干</span><br><span class="line">        if (nums == null || nums.length == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 1. 先把所有数字“丢进”一个 HashSet，相当于建立一个“快速查找表”</span><br><span class="line">        Set&lt;Integer&gt; numSet = new HashSet&lt;&gt;();</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            numSet.add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int maxLength = 0;   // 用来记录全局最长连续序列的长度</span><br><span class="line"></span><br><span class="line">        // 2. 开始遍历数组</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            // 2.1 只有当“num-1”不在集合里时，num 才是一个连续序列的“开头”</span><br><span class="line">            if (!numSet.contains(num - 1)) &#123;</span><br><span class="line">                int currentNum = num;    // 从当前这个“开头”出发</span><br><span class="line">                int currentLength = 1;   // 目前这个序列长度先算 1（只有自己）</span><br><span class="line"></span><br><span class="line">                // 2.2 不断看“下一个数字”在不在集合里，如果在就继续往后数</span><br><span class="line">                while (numSet.contains(currentNum + 1)) &#123;</span><br><span class="line">                    currentNum++;      // 挪到下一个数字</span><br><span class="line">                    currentLength++;   // 序列长度 +1</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 2.3 这一整条序列数完了，更新全局最大值</span><br><span class="line">                maxLength = Math.max(maxLength, currentLength);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 3. 最后把最长长度返回即可</span><br><span class="line">        return maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ 说明：</p><ol><li>时间复杂度<br> 建集合：for num in nums 一次遍历，O(n)。<br> 再遍历数组：看似两层循环，但每个数字最多被“往后数”一次；<br> 一旦某个数字被当作序列内部元素（非起点）时，根本不会进入内层 while。<br> 所以总工作量 ≤ 2n，仍属 O(n)。</li><li>空间复杂度<br> 额外开了一个集合 num_set，最坏存下所有元素，大小 n，因此 O(n)。<br>总结：<br> 算法只多占一份“哈希表”内存，却换来线性时间，是典型“空间换时间”的套路。</li></ol><h3 id="python版"><a href="#python版" class="headerlink" title="python版"></a>python版</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">from typing import List</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def longestConsecutive(self, nums: List[int]) -&gt; int:</span><br><span class="line">        # 1. 空数组直接返回 0</span><br><span class="line">        if not nums:</span><br><span class="line">            return 0</span><br><span class="line"></span><br><span class="line">        # 2. 把所有数字放进集合，方便 O(1) 查找</span><br><span class="line">        num_set = set(nums)</span><br><span class="line"></span><br><span class="line">        max_length = 0  # 全局最长连续序列长度</span><br><span class="line"></span><br><span class="line">        # 3. 遍历每个数字</span><br><span class="line">        for num in nums:</span><br><span class="line">            # 3.1 只有当 num-1 不在集合里时，num 才是一个序列的“开头”</span><br><span class="line">            if num - 1 not in num_set:</span><br><span class="line">                current_num = num      # 从当前数字开始往后数</span><br><span class="line">                current_length = 1     # 目前序列长度至少为 1（自己）</span><br><span class="line"></span><br><span class="line">                # 3.2 不断看“下一个数字”是否存在</span><br><span class="line">                while current_num + 1 in num_set:</span><br><span class="line">                    current_num += 1   # 挪到下一个数字</span><br><span class="line">                    current_length += 1  # 长度 +1</span><br><span class="line"></span><br><span class="line">                # 3.3 更新全局最大值</span><br><span class="line">                max_length = max(max_length, current_length)</span><br><span class="line"></span><br><span class="line">        # 4. 返回最长长度</span><br><span class="line">        return max_length</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 简单测试</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    print(Solution().longestConsecutive([100, 4, 200, 1, 3, 2]))  # 输出 4</span><br><span class="line">    print(Solution().longestConsecutive([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]))  # 输出 9</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>法算day2</title>
      <link href="/lief/%E6%B3%95%E7%AE%97day2/"/>
      <url>/lief/%E6%B3%95%E7%AE%97day2/</url>
      
        <content type="html"><![CDATA[<h1 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a>字母异位词分组</h1><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</p><p>示例 1:<br>输入: strs &#x3D; [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]<br>输出: [[“bat”],[“nat”,”tan”],[“ate”,”eat”,”tea”]]</p><p>解释：<br>在 strs 中没有字符串可以通过重新排列来形成 “bat”。<br>字符串 “nat” 和 “tan” 是字母异位词，因为它们可以重新排列以形成彼此。<br>字符串 “ate” ，”eat” 和 “tea” 是字母异位词，因为它们可以重新排列以形成彼此。</p><p>示例 2:<br>输入: strs &#x3D; [“”]<br>输出: [[“”]]</p><p>示例 3:<br>输入: strs &#x3D; [“a”]<br>输出: [[“a”]]</p><p>提示：<br>1 &lt;&#x3D; strs.length &lt;&#x3D; 104<br>0 &lt;&#x3D; strs[i].length &lt;&#x3D; 100<br>strs[i] 仅包含小写字母</p><h3 id="java版"><a href="#java版" class="headerlink" title="java版"></a>java版</h3><h4 id="方法一：排序签名，即对字符排序"><a href="#方法一：排序签名，即对字符排序" class="headerlink" title="方法一：排序签名，即对字符排序"></a>方法一：排序签名，即对字符排序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 主类：GroupAnagrams</span><br><span class="line"> * 功能：把一堆字符串中所有“字母异位词”自动归到同一组。</span><br><span class="line"> * 字母异位词：字母相同、出现次数相同，只是顺序不同，如 &quot;eat&quot; 和 &quot;tea&quot;。</span><br><span class="line"> */</span><br><span class="line">public class GroupAnagrams &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 唯一公开接口：groupAnagrams</span><br><span class="line">     * 参数：strs – 待分组的原始字符串数组，可能为空、可能含空串</span><br><span class="line">     * 返回：List&lt;List&lt;String&gt;&gt; – 每一层 List 就是一个分组，组内字符串互为异位词</span><br><span class="line">     */</span><br><span class="line">    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        /* ---------- 1. 边界保护 ---------- */</span><br><span class="line">        if (strs == null || strs.length == 0) &#123;</span><br><span class="line">            // 外面传进来的是空指针或空数组，直接返回“空列表”，避免后面代码抛异常</span><br><span class="line">            return new ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* ---------- 2. 准备哈希表 ---------- */</span><br><span class="line">        // key（String）：某个“签名”，所有互为异位词的字符串都会生成完全相同的签名</span><br><span class="line">        // value（List&lt;String&gt;）：属于这个签名的所有原始字符串</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        /* ---------- 3. 遍历每个字符串 ---------- */</span><br><span class="line">        for (String s : strs) &#123;                 // s 可能是 &quot;&quot;，也可能是 &quot;aabbCc&quot; 等任意小写字母</span><br><span class="line">            /* 3.1 生成签名：把字符排序后得到的字符串就是签名</span><br><span class="line">               原因：异位词排序后必然得到同一串字符，例如 &quot;eat&quot;、&quot;tea&quot; 排序后都是 &quot;aet&quot; */</span><br><span class="line">            char[] chars = s.toCharArray();     // 把当前字符串拆成字符数组，方便排序</span><br><span class="line">            Arrays.sort(chars);                 // 快速排序，复杂度 O(k log k)，k 为字符串长度</span><br><span class="line">            String key = new String(chars);     // 再把排好序的字符数组拼回字符串，得到签名</span><br><span class="line"></span><br><span class="line">            /* 3.2 把原始字符串挂到对应签名下面</span><br><span class="line">               computeIfAbsent 的意思是：如果 map 里还没有这个签名，就新建一个空 ArrayList 并返回；</span><br><span class="line">               如果已经有，就直接返回原来的 List。无论哪种情况，add(s) 都会把当前字符串放进这个 List */</span><br><span class="line">            map.computeIfAbsent(key, k -&gt; new ArrayList&lt;&gt;()).add(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* ---------- 4. 组装最终结果 ---------- */</span><br><span class="line">        // map.values() 拿到所有分组 List，再套一层 ArrayList 就是题目要的返回格式</span><br><span class="line">        return new ArrayList&lt;&gt;(map.values());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* ---------- 5. 简单自测 ---------- */</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        GroupAnagrams solution = new GroupAnagrams();</span><br><span class="line">        String[] strs = &#123;&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;&#125;;</span><br><span class="line">        // 期望输出：[[eat, tea, ate], [tan, nat], [bat]]（顺序可能不同）</span><br><span class="line">        System.out.println(solution.groupAnagrams(strs));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ 说明：<br>算法复杂度<br>时间：O(n·k log k)，n 为字符串个数，k 为字符串最大长度（排序耗时）。<br>空间：O(n·k)，用于存储 map 与结果。</p><h2 id="代码疑惑点答疑"><a href="#代码疑惑点答疑" class="headerlink" title="代码疑惑点答疑"></a>代码疑惑点答疑</h2><h3 id="疑点一"><a href="#疑点一" class="headerlink" title="疑点一"></a>疑点一</h3><p><code>public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs)</code> 这一长串看起来吓人，其实每个关键字都在“报户口”——告诉你 <strong>谁都能调用、给的是字符串数组、还回来的是两层口袋的字符串</strong>。一句话拆 6 段解释：</p><ol><li><p><code>public</code><br>“大家都能用”。换成 <code>private</code> 就只能类内部自己玩，别人调不到。</p></li><li><p><code>List&lt;List&lt;String&gt;&gt;</code><br>返回类型：两层 List 嵌套。  </p><ul><li>外层 <code>List</code> 的每一项代表 <strong>一个分组</strong>；  </li><li>内层 <code>List&lt;String&gt;</code> 装的是 <strong>该分组里的所有字符串</strong>。<br>为什么用接口 <code>List</code> 而不用具体类？<br>面向接口编程：调用者只关心“它是个列表”，不关心你背后是 <code>ArrayList</code> 还是 <code>LinkedList</code>，给实现留余地。</li></ul></li><li><p><code>groupAnagrams</code><br>方法名，见名知意：把 anagrams（字母异位词）group（分组）。</p></li><li><p><code>(String[] strs)</code><br>形参：一个字符串数组，里面扔进来一堆原始单词，等待被分类。</p></li><li><p>为什么没有 <code>static</code>？<br>需要 <strong>先 new 一个对象</strong> 再调用，这样方法内部可以访问到对象级别的字段（虽然现在没用，但预留扩展）。如果写成 <code>static</code>，就成了工具方法，属于类本身，无法访问实例成员。</p></li><li><p>为什么泛型要写两次 <code>&lt;String&gt;</code>？<br>Java 泛型不支持“裸”嵌套，必须写全。<code>List&lt;List&lt;String&gt;&gt;</code> 读作：一个列表，里面的元素还是“装字符串的列表”。</p></li></ol><p>总结：<br>这句声明就是一份 <strong>方法招牌</strong>——“公开营业，收字符串数组，返分组列表，欢迎来调”。</p><h3 id="疑点二"><a href="#疑点二" class="headerlink" title="疑点二"></a>疑点二</h3><p><code>return new ArrayList&lt;&gt;();</code> 这一行干的事情可以拆成三步看：</p><ol><li><p><strong>new ArrayList&lt;&gt;()</strong><br>在堆上真正创建了一个 <strong>空的</strong> <code>ArrayList</code> 对象（底层数组长度默认 0，第一次 add 时才会扩容）。</p></li><li><p><strong>泛型推断</strong><br>因为方法返回值已经被编译器确定为 <code>List&lt;List&lt;String&gt;&gt;</code>，所以这里的 <code>&lt;&gt;</code> 被自动推断成 <code>ArrayList&lt;List&lt;String&gt;&gt;()</code>；你不用重复写泛型参数。</p></li><li><p><strong>return 出去</strong><br>你拿到手的 <strong>实际上</strong> 是一个：</p><ul><li><strong>空</strong>的、</li><li><strong>可变的</strong>、</li><li><strong>顺序保持的</strong>、</li><li><strong>允许重复元素</strong>的<br><code>ArrayList</code> 实例，只不过对外展现的类型是它的接口 <code>List&lt;List&lt;String&gt;&gt;</code>。</li></ul></li></ol><p>一句话：<br>“别人眼里你只是‘空列表’，本质上就是刚出炉、还没装任何分组的 <code>ArrayList</code> 对象。”</p><h3 id="疑点三"><a href="#疑点三" class="headerlink" title="疑点三"></a>疑点三</h3><p>for (String s : strs) 是 Java 的“增强版 for 循环”（也叫 foreach），它把“索引、边界判断、自增”这些脏活全部藏起来，让你只关心 每个元素本身。<br>逐字拆解：<br>for (<br>循环关键字，开场白。<br>String s<br>循环变量：每次进入循环体，都会把当前拿到的字符串塞进这个局部变量 s 里，类型必须和数组元素一致（这里是 String）。<br>:<br>读作“在……里面”，官方叫“in”。<br>strs<br>要被遍历的 数组或 Iterable 集合，这里是我们传进来的 String[] strs。<br>执行流程（伪代码等价）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; strs.length; i++) &#123;</span><br><span class="line">    String s = strs[i];   // 自动帮你取下标、赋值</span><br><span class="line">    // ↓ 你自己的代码</span><br><span class="line">    ...                   // 这里写对 s 的操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>索引 i 由编译器自动生成，但你 看不见、也用不到。<br>特点<br>只能 从前到后 一趟扫，不能跳着走，也不能反向。<br>不能修改数组长度（不能 add&#x2F;remove），但 可以读取、可以修改元素本身（如果元素是可变对象）。<br>代码更短，少了下标越界风险，可读性高。<br>在本例里：<br>每轮循环 s 依次代表 “eat”、”tea”、”tan”……直到最后一个单词，循环自动结束。<br>你只需要把注意力放在“拿到一个字符串后怎么生成签名、怎么塞进 map”即可，下标那些事编译器全包。</p><h3 id="疑点四"><a href="#疑点四" class="headerlink" title="疑点四"></a>疑点四</h3><p>把这一行拆成“两句话”看，就秒懂：<br>map.computeIfAbsent(key, k -&gt; new ArrayList&lt;&gt;())<br>意思是：<br>“如果 map 里还没有这个 key，就新建一个 空 ArrayList 并放进 map，然后把这个 List 返回；<br>如果已经存在，就直接把原来那个 List 返回。”<br>.add(s)<br>拿到上一步返回的 List（不管是刚新建的还是原来就有的），把当前字符串 s 塞进去。<br>所以整行等价于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = map.get(key);     // 先查</span><br><span class="line">if (list == null) &#123;                   // 没有就建</span><br><span class="line">    list = new ArrayList&lt;&gt;();</span><br><span class="line">    map.put(key, list);</span><br><span class="line">&#125;</span><br><span class="line">list.add(s);                          // 再装</span><br></pre></td></tr></table></figure><p>只是 computeIfAbsent 把“查-判-建-放”四步一次性做完，并直接返回那个 一定存在的 List，让你立刻能 .add(s)。<br>变量名 k 是 Lambda 的形参，代表 key，这里没用到，起个占位符名字即可。</p><h3 id="重点理解"><a href="#重点理解" class="headerlink" title="重点理解"></a>重点理解</h3><p>下面用<strong>一个完整的字符串</strong>当例子，把<br><code>map.computeIfAbsent(key, k -&gt; new ArrayList&lt;&gt;()).add(s);</code><br>的每一步都“慢放”给你看。</p><p>假设当前字符串 s &#x3D; “tea”</p><ol><li><p>生成签名<br>char[] chars &#x3D; “tea”.toCharArray() → 排序 → {‘a’,’e’,’t’} → key &#x3D; “aet”</p></li><li><p>看 map 里有没有 key&#x3D;”aet”<br>此时 map 还是空的，get(“aet”) 会返回 null。</p></li><li><p>进入 computeIfAbsent<br>因为找不到，于是执行 Lambda：k -&gt; new ArrayList&lt;&gt;()<br>新建一个空 ArrayList，把它放进 map，并把这个 List 返回。<br>此刻内存里变成：<br>map &#x3D; {“aet” → []}   （空列表）</p></li><li><p>返回的 List 立刻 .add(s)<br>[].add(“tea”) → 列表变成 [“tea”]<br>最终 map 是：<br>{“aet” → [“tea”]}</p></li><li><p>下一个循环如果碰到 “eat”<br>签名还是 “aet”，这次 map 里已存在，computeIfAbsent 直接返回原列表 [“tea”]，<br>再 .add(“eat”) → 列表变成 [“tea”, “eat”]，无需再建 ArrayList。</p></li></ol><p>一句话：<br>“第一次来就给你新建个口袋，后面再来同名签名直接往旧口袋里继续扔。”</p><h3 id="python版"><a href="#python版" class="headerlink" title="python版"></a>python版</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">from collections import defaultdict  # 引入一个方便的字典类，后面会解释</span><br><span class="line">from typing import List              # 只是告诉 Python 我们要用 List 做类型提示，不写也能跑</span><br><span class="line"></span><br><span class="line">class Solution:                      # 把所有功能包在一个类里，刷题平台喜欢这种写法</span><br><span class="line">    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:</span><br><span class="line">        # 1. 建一个“有默认值”的字典：当访问一个不存在的 key 时，它会自动先放一个空列表进去</span><br><span class="line">        groups = defaultdict(list)</span><br><span class="line"></span><br><span class="line">        # 2. 逐个看输入的字符串</span><br><span class="line">        for s in strs:</span><br><span class="line">            # 3. 把字符串里的字母按字母表顺序排好，变成“签名”</span><br><span class="line">            #    例如 &quot;tea&quot; -&gt; 排序后变成 &quot;aet&quot;</span><br><span class="line">            key = &#x27;&#x27;.join(sorted(s))</span><br><span class="line"></span><br><span class="line">            # 4. 把原字符串挂到这个签名对应的列表里</span><br><span class="line">            #    同一签名下的所有字符串互为字母异位词</span><br><span class="line">            groups[key].append(s)</span><br><span class="line"></span><br><span class="line">        # 5. 把字典里所有的列表一次性拿出来，就是最终答案</span><br><span class="line">        return list(groups.values())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 下面这段是“自测”代码，只在直接运行本文件时生效</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    print(Solution().groupAnagrams([&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]))</span><br><span class="line">    # 期望输出: [[&#x27;eat&#x27;, &#x27;tea&#x27;, &#x27;ate&#x27;], [&#x27;tan&#x27;, &#x27;nat&#x27;], [&#x27;bat&#x27;]]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>法算day1</title>
      <link href="/lief/%E6%B3%95%E7%AE%97day1/"/>
      <url>/lief/%E6%B3%95%E7%AE%97day1/</url>
      
        <content type="html"><![CDATA[<h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。<br>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。<br>你可以按任意顺序返回答案。</p><p>示例 1：</p><p>输入：nums &#x3D; [2,7,11,15], target &#x3D; 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。<br>示例 2：</p><p>输入：nums &#x3D; [3,2,4], target &#x3D; 6<br>输出：[1,2]<br>示例 3：</p><p>输入：nums &#x3D; [3,3], target &#x3D; 6<br>输出：[0,1]</p><h3 id="java版"><a href="#java版" class="headerlink" title="java版"></a>java版</h3><h4 id="方法一：使用了哈希表（HashMap）来高效地查找两个数的和是否等于目标值"><a href="#方法一：使用了哈希表（HashMap）来高效地查找两个数的和是否等于目标值" class="headerlink" title="方法一：使用了哈希表（HashMap）来高效地查找两个数的和是否等于目标值"></a>方法一：使用了哈希表（HashMap）来高效地查找两个数的和是否等于目标值</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashMap;</span><br><span class="line"></span><br><span class="line">public class TwoSum &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        // 1. 先准备一本“字典”，名字叫 map</span><br><span class="line">    //    左边 key 存“数值”，右边 value 存“这个数值的下标”</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    // 2. 从头到尾扫一遍数组</span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">        // 3. 我想找的“另一半”是多少？</span><br><span class="line">        //    如果 target 是 9，当前数是 2，那我就要找 7</span><br><span class="line">        int need = target - nums[i];</span><br><span class="line"></span><br><span class="line">        // 4. 翻字典看看：之前有没有出现过 7？</span><br><span class="line">        //    如果出现过，它就记录在 map 里，直接拿到它的下标</span><br><span class="line">        if (map.containsKey(need)) &#123;</span><br><span class="line">            // 5. 找到了！把“之前那个数的下标”和“现在这个数字的下标”一起返回</span><br><span class="line">            return new int[]&#123;map.get(need), i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 6. 如果字典里没有 7，就把当前的“数-下标”写进字典</span><br><span class="line">        //    这样后面遇到 7 时就能查到今天的 2 了</span><br><span class="line">        map.put(nums[i], i);//将这对&#x27;值-下标&#x27;存入字典中,数组里的元素被逐步存入了 map。</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        // 题目保证有解，这里只是为了代码能通过编译</span><br><span class="line">        throw new IllegalArgumentException(&quot;No two sum solution&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 简单测试</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TwoSum solution = new TwoSum();</span><br><span class="line">        int[] nums = &#123;2, 7, 11, 15&#125;;</span><br><span class="line">        int target = 9;</span><br><span class="line">        int[] result = solution.twoSum(nums, target);</span><br><span class="line">        System.out.println(&quot;[&quot; + result[0] + &quot;, &quot; + result[1] + &quot;]&quot;);  // 预期输出 [0, 1]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>✅ 说明：<br>时间复杂度：O(n)，只需要遍历一次数组。<br>空间复杂度：O(n)，最坏情况下需要存储所有元素。<br>不能重复使用同一个元素：通过 map 存储的是已经遍历过的元素，确保不会重复使用。<br>如果你需要处理多个解或者有其他限制条件，也可以进一步扩展这个逻辑。</p><h4 id="方法二：暴力枚举——-数据量极小（n-≤-200）时图省事"><a href="#方法二：暴力枚举——-数据量极小（n-≤-200）时图省事" class="headerlink" title="方法二：暴力枚举—— 数据量极小（n ≤ 200）时图省事"></a>方法二：暴力枚举—— 数据量极小（n ≤ 200）时图省事</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public int[] twoSum_brute(int[] nums, int target) &#123;</span><br><span class="line">    for (int i = 0; i &lt; nums.length - 1; i++)</span><br><span class="line">        for (int j = i + 1; j &lt; nums.length; j++)</span><br><span class="line">            if (nums[i] + nums[j] == target)</span><br><span class="line">                return new int[]&#123;i, j&#125;;</span><br><span class="line">    throw new IllegalArgumentException(&quot;No solution&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ 说明：<br>时间 O(n²) 空间 O(1)</p><h3 id="python版"><a href="#python版" class="headerlink" title="python版"></a>python版</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">from typing import List</span><br><span class="line"></span><br><span class="line"># 解法 1：暴力枚举</span><br><span class="line">def two_sum_bruteforce(nums: List[int], target: int) -&gt; List[int]:</span><br><span class="line">    n = len(nums)</span><br><span class="line">    for i in range(n):</span><br><span class="line">        for j in range(i + 1, n):</span><br><span class="line">            if nums[i] + nums[j] == target:</span><br><span class="line">                return [i, j]</span><br><span class="line">    return []   # 题目保证有解，这里不会执行</span><br><span class="line"></span><br><span class="line"># 解法 2：哈希表一次遍历</span><br><span class="line">def two_sum(nums: List[int], target: int) -&gt; List[int]:</span><br><span class="line">    seen = &#123;&#125;                       # 值 -&gt; 下标</span><br><span class="line">    for j, num in enumerate(nums):  # 当前下标 j</span><br><span class="line">        need = target - num</span><br><span class="line">        if need in seen:            # 之前已经遇到过符合条件的另一半</span><br><span class="line">            return [seen[need], j]</span><br><span class="line">        seen[num] = j               # 记录值和下标</span><br><span class="line">    return []                       # 题目保证有解，这里不会执行</span><br><span class="line"></span><br><span class="line"># 简单测试</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    nums = [2, 7, 11, 15]</span><br><span class="line">    target = 9</span><br><span class="line">    print(two_sum(nums, target))          # 输出: [0, 1]</span><br><span class="line">    print(two_sum_bruteforce(nums, target))  # 输出: [0, 1]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot学习日志</title>
      <link href="/lief/Springboot%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/lief/Springboot%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot入门-SpringBoot-hello-LEE"><a href="#SpringBoot入门-SpringBoot-hello-LEE" class="headerlink" title="SpringBoot入门 - SpringBoot hello LEE"></a>SpringBoot入门 - SpringBoot hello LEE</h1><h3 id="通过-IDE-集成工具创建"><a href="#通过-IDE-集成工具创建" class="headerlink" title="通过 IDE 集成工具创建"></a>通过 IDE 集成工具创建</h3><p>IntelliJ IDEA：<br>File → New → Project<br>选择 “Spring Boot”<br>配置项目信息和依赖项</p><img src="/lief/Springboot%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/1.png" class=""><img src="/lief/Springboot%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/2.png" class=""><p>点击create，完成创建</p><h3 id="修改Sb1Application代码即可"><a href="#修改Sb1Application代码即可" class="headerlink" title="修改Sb1Application代码即可"></a>修改Sb1Application代码即可</h3><img src="/lief/Springboot%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/4.png" class=""><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.example.sb1;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.http.HttpStatus;</span><br><span class="line">import org.springframework.http.ResponseEntity;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">// Spring Boot应用程序的主类，包含启动方法和REST控制器</span><br><span class="line">@SpringBootApplication</span><br><span class="line">@RestController</span><br><span class="line"></span><br><span class="line">public class Sb1Application &#123;</span><br><span class="line"></span><br><span class="line">    // 程序入口点，启动Spring Boot应用</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Sb1Application.class, args);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    // 处理GET请求的/hello端点，返回问候信息</span><br><span class="line">    @GetMapping(&quot;/hello&quot;)</span><br><span class="line">    public ResponseEntity&lt;String&gt; hello() &#123;</span><br><span class="line">        // 返回包含&quot;hello LEE&quot;消息和HTTP 200状态的响应</span><br><span class="line">        return new ResponseEntity&lt;&gt;(&quot;hello LEE&quot;, HttpStatus.OK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行后地址栏输入http-localhost-8080-hello"><a href="#运行后地址栏输入http-localhost-8080-hello" class="headerlink" title="运行后地址栏输入http://localhost:8080/hello"></a>运行后地址栏输入<a href="http://localhost:8080/hello">http://localhost:8080/hello</a></h2><img src="/lief/Springboot%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/3.png" class="">]]></content>
      
      
      
        <tags>
            
            <tag> 学习日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>终不似 少年游</title>
      <link href="/lief/%E7%BB%88%E4%B8%8D%E4%BC%BC-%E5%B0%91%E5%B9%B4%E6%B8%B8/"/>
      <url>/lief/%E7%BB%88%E4%B8%8D%E4%BC%BC-%E5%B0%91%E5%B9%B4%E6%B8%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="高达有感"><a href="#高达有感" class="headerlink" title="高达有感"></a>高达有感</h1><p>不知道，我是何时听到过高达这两个字，那时候似乎见过，给人的印象就是很帅，那时候还小，没钱O(∩_∩)O哈哈~。<br>就在今年偶然一次刷到视频，就打算买一个玩玩，当然是ko。以下是这几个月陆陆续续拼的，记录一下吧！</p><h2 id="樱花自由"><a href="#樱花自由" class="headerlink" title="樱花自由"></a>樱花自由</h2><p>jms的，第一次把头部拼出来，那感觉，和印象中的一样帅！那时很激动，<br>不过第一次拼并不会摆姿势，网友调侃说，和wjk的一样，当时没有听懂，还特地搜了一下。<br><img src="https://eedbdc0.webp.li/docs/1755100362543.jpg"></p><h2 id="马克兔"><a href="#马克兔" class="headerlink" title="马克兔"></a>马克兔</h2><p>第一个拼完，有点意犹未尽，又买了一个，还是jms的；<br>因为刚入这个圈，不知道买这个还要检查板件，拼到一半才发现少一个零件，还好商家是好人，给我免费补发了，给商家点赞！<br><img src="https://eedbdc0.webp.li/docs/1755101070723.jpg"></p><h2 id="飞升自由"><a href="#飞升自由" class="headerlink" title="飞升自由"></a>飞升自由</h2><p>就在这段时间，看别人测评视频，看了好久，最终选了这个，不幸的是，再剪面罩时，没剪好，导致有点毁容，<br>我记得当时那么点大的东西，我粘了好久，才让脸还算看的过去。<br><img src="https://eedbdc0.webp.li/docs/1755101204947.jpg"></p><h2 id="RX-78-元祖"><a href="#RX-78-元祖" class="headerlink" title="RX-78 元祖"></a>RX-78 元祖</h2><p>刚开始入圈的时候，觉得元祖的帅有点欣赏不来，没想到后面不知道咋回事，就是觉得很帅，而且还是带骨架的，没玩过，想试试！<br><img src="https://eedbdc0.webp.li/docs/1755101248840.jpg"></p><h2 id="强袭自由"><a href="#强袭自由" class="headerlink" title="强袭自由"></a>强袭自由</h2><p>这个是我买过最贵的了，虽然只是个ko，最强最帅，某次价格合适就入手了，真的很帅哈哈哈。<br><img src="https://eedbdc0.webp.li/docs/1755101323439.jpg"></p><h2 id="RX-93-v高达"><a href="#RX-93-v高达" class="headerlink" title="RX-93 v高达"></a>RX-93 v高达</h2><p>牛高达，不得不说，在上面这段时间，没刷到过；某次看到，真帅，这比例简直了，太帅了，心动不已；<br>奈何正版价格太贵了，当时想着等等ko吧，出来必买，你看，许愿成功；感谢龍哥！<br><img src="https://eedbdc0.webp.li/docs/1755101667372.jpg"><br><img src="https://eedbdc0.webp.li/docs/1755101693952.jpg"></p><h1 id="一些合照"><a href="#一些合照" class="headerlink" title="一些合照"></a>一些合照</h1><p>咔咔咔，一顿猛拍！其实身边已经没人可以分享了；<br>但是dy会大数据推送，我经常评论分享，那种互相有回应的感觉真棒！没想到是胶佬给的，感动！<br>此刻的心情是应该很长一段时间不会再拼了，我也不知道为啥，可能自己不小了吧？<br>现在的时间是2025年12点56分！胶佬们，早点休息，爱护自己哦！<br><img src="https://eedbdc0.webp.li/docs/1755101763293.jpg"><br><img src="https://eedbdc0.webp.li/docs/1755101787183.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 生活日常 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图床搭建(Cloudflare R2)</title>
      <link href="/lief/%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA-Cloudflare-R2/"/>
      <url>/lief/%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA-Cloudflare-R2/</url>
      
        <content type="html"><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>本次搭建需用到域名，Cloudflare R2，PicGo</p><h3 id="插曲"><a href="#插曲" class="headerlink" title="插曲"></a>插曲</h3><p>TIP：创作此次blog用到以下指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post 图床搭建&quot;(Cloudflare R2)&quot;</span><br></pre></td></tr></table></figure><h2 id="创建存储桶"><a href="#创建存储桶" class="headerlink" title="创建存储桶"></a>创建存储桶</h2><p>进入Cloudflare，左边栏有R2对象存储，进入创建存储桶。<br><img src="https://eedbdc0.webp.li/docs/1754979785873.png"><br>创建后点击设置，设置自定义域，然后连接域；<br>返回概述，点击创建令牌，权限选对象读和写，其他不用管，直接创建api令牌，显示的画面请复制内容，因为只显示一次。</p><h2 id="连接PicGO"><a href="#连接PicGO" class="headerlink" title="连接PicGO"></a>连接PicGO</h2><p>打开PIcGo 下载插件，直接在插件搜索s3，点击安装；打开图床设置会有下载的插件，根据复制内容填写即可<br><img src="https://eedbdc0.webp.li/docs/1754980061584.png"><br>即创建成功！</p><h3 id="TIP"><a href="#TIP" class="headerlink" title="TIP"></a>TIP</h3><p>本次使用的图片均为图床里的图片。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建日志，持续记录</title>
      <link href="/lief/%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%9C%9D%E5%9C%A3/"/>
      <url>/lief/%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%9C%9D%E5%9C%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h1><p>前提：配置cloudflare，托管域名<br>开发：需安装Node、GIt、VScode(可选)<br>检查：调用cmd，在命令行中输入 node -v 检查版本信息；git，验证安装完毕后，Windows 用户会在开始菜单中看到 Git Bash 等应用</p><h1 id="2-进行开发"><a href="#2-进行开发" class="headerlink" title="2.进行开发"></a>2.进行开发</h1><h2 id="2-1配置Git用户名和邮箱："><a href="#2-1配置Git用户名和邮箱：" class="headerlink" title="2.1配置Git用户名和邮箱："></a>2.1配置Git用户名和邮箱：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;你的用户名&quot;</span><br><span class="line">git config --global user.email &quot;你的邮箱&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过git config -l 验证是否成功</p><h2 id="2-2配置公钥链接github"><a href="#2-2配置公钥链接github" class="headerlink" title="2.2配置公钥链接github"></a>2.2配置公钥链接github</h2><p>生成SSH公钥</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;你的邮箱&quot;</span><br></pre></td></tr></table></figure><p>一路回车生成密钥，进入 .ssh 文件夹复制 id_rsa.pub 公钥内容，配置到 Github 的 SSH 设置中。</p><h3 id="在windows电脑上："><a href="#在windows电脑上：" class="headerlink" title="在windows电脑上："></a>在windows电脑上：</h3><p>打开C盘下用户文件夹下的.ssh的文件夹，会看到以下文件<br>id_rsa 私钥<br>id_rsa.pub 公钥</p><p>找到公钥匙，并复制，打开GitHub开始配置，将 SSH KEY 配置到 GitHub<br>进入github，点击右上角头像 选择settings，进入设置页后选择 SSH and GPG keys，名字随便起，公钥填到Key那一栏</p><p>测试连接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>第一次连接会提示Are you sure you want to continue connecting (yes&#x2F;no&#x2F;[fingerprint])?，输入yes即可</p><img src="/lief/%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%9C%9D%E5%9C%A3/r1.png" class=""><p>插曲：第一次写博客，发现不会插入图片,首先得cmd安装插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-asset-img --save</span><br></pre></td></tr></table></figure><h2 id="2-3创建-GitHub-io-仓库"><a href="#2-3创建-GitHub-io-仓库" class="headerlink" title="2.3创建 GitHub.io 仓库"></a>2.3创建 GitHub.io 仓库</h2><p>点击右上角的 + 按钮，选择新建仓库，命名格式为 &lt;用户名&gt;.github.io，(注意：前缀必须为用户名)选择公开 Public。<br>点击 Creat repository 进行创建即可。  </p><h2 id="2-4初始化Hexo博客"><a href="#2-4初始化Hexo博客" class="headerlink" title="2.4初始化Hexo博客"></a>2.4初始化Hexo博客</h2><p>1.创建文件夹保存博客源码<br>   例如D:&#x2F;Hexo<br>2.安装Hexo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli &amp;&amp; hexo -v</span><br></pre></td></tr></table></figure><p>3.初始化 Hexo 项目安装依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog-demo</span><br><span class="line">cd blog-demo</span><br><span class="line">npm i</span><br></pre></td></tr></table></figure><p>现在你的文件夹会有这些内容</p><img src="/lief/%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%9C%9D%E5%9C%A3/2025-08-11-16-36-29.png" class=""><p>4.启动项目并验证:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo cl ; hexo s</span><br></pre></td></tr></table></figure><p>在终端输出栏的网址<a href="http://localhost:4000/%E8%AE%BF%E9%97%AE%EF%BC%8C%E6%9F%A5%E7%9C%8B%E6%9C%80%E7%BB%88%E6%95%88%E6%9E%9C%E3%80%82">http://localhost:4000/访问，查看最终效果。</a></p><h2 id="2-5将静态博客挂载到-GitHub-Pages"><a href="#2-5将静态博客挂载到-GitHub-Pages" class="headerlink" title="2.5将静态博客挂载到 GitHub Pages"></a>2.5将静态博客挂载到 GitHub Pages</h2><p>1.修改 _config.yml 文件，配置 repository 为你的 GitHub 地址，分支改为 main：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:你的用户名/你的用户名.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><img src="/lief/%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%9C%9D%E5%9C%A3/2025-08-11-16-47-45.png" class=""><p>2.安装 hexo-deployer-git：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>3.部署到 GitHub</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Git BASH终端,必须是管理员身份，cmd同理</span><br><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy  </span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line"></span><br><span class="line">// VSCODE终端</span><br><span class="line">hexo cl; hexo g; hexo d</span><br></pre></td></tr></table></figure><img src="/lief/%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%9C%9D%E5%9C%A3/2025-08-11-16-51-15.png" class=""><p>访问 https:&#x2F;&#x2F;&lt;用户名&gt;.github.io&#x2F; 以查看博客。</p><h2 id="2-6将静态博客挂载到-Cloudflare-Pages"><a href="#2-6将静态博客挂载到-Cloudflare-Pages" class="headerlink" title="2.6将静态博客挂载到 Cloudflare Pages"></a>2.6将静态博客挂载到 Cloudflare Pages</h2><p>1.通过 Cloudflare Pages 连接 Git 仓库。<br>2。选择刚刚的存储库，点击保存并部署。<br>3.部署成功后，访问 Cloudflare 提供的链接。<br>如有自定义域名，可以在 Cloudflare Pages 中绑定。没有建议去申请，这样博客就不被墙了。<br>4.至此，你就可以用自己的域名访问自己的博客了</p><h1 id="3-安装主题"><a href="#3-安装主题" class="headerlink" title="3.安装主题"></a>3.安装主题</h1><p>HEXO主题有很多，<a href="https://hexo.io/themes/">点击跳转</a>可以选择自己喜欢的进行安装，本次选的是anzhiyu的</p><h2 id="3-1-Git安装"><a href="#3-1-Git安装" class="headerlink" title="3.1 Git安装"></a>3.1 Git安装</h2><p>在博客根目录里安装最新版【推荐】：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b main https://github.com/anzhiyu-c/hexo-theme-anzhiyu.git themes/anzhiyu</span><br></pre></td></tr></table></figure><h2 id="3-2安装-Pug-和-Stylus-渲染插件"><a href="#3-2安装-Pug-和-Stylus-渲染插件" class="headerlink" title="3.2安装 Pug 和 Stylus 渲染插件"></a>3.2安装 Pug 和 Stylus 渲染插件</h2><p>运行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><p>使用主题，修改 Hexo 配置文件 _config.yml，将主题theme改为 anzhiyu。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: anzhiyu</span><br></pre></td></tr></table></figure><h2 id="3-3覆盖配置"><a href="#3-3覆盖配置" class="headerlink" title="3.3覆盖配置"></a>3.3覆盖配置</h2><p>覆盖配置可将主题配置放置在 anzhiyu 目录之外，避免在更新主题时丢失自定义的配置。通过 Npm 安装主题的用户可忽略，其他用户建议学习使用。Windows 用户复制 &#x2F;themes&#x2F;anzhiyu&#x2F;_config.yml 到 Hexo 根目录，并重命名为 _config.anzhiyu.yml。后续修改主题配置只需更新 _config.anzhiyu.yml。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>_config.anzhiyu.yml 中的配置优先级高于 _config.yml。<br>每次更新主题时可能存在配置变更，请查看更新说明，并手动同步修改 _config.anzhiyu.yml。<br>可通过 hexo g –debug 查看覆盖配置是否生效。<br>若要将某些配置覆盖为空，注意不要删除主键。</p><h2 id="3-4主题部署就完成了！别忘了推送更新上线"><a href="#3-4主题部署就完成了！别忘了推送更新上线" class="headerlink" title="3.4主题部署就完成了！别忘了推送更新上线"></a>3.4主题部署就完成了！别忘了推送更新上线</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//本地预览</span><br><span class="line">hexo cl; hexo s</span><br><span class="line">//推送更新上线</span><br><span class="line">hexo cl; hexo g; hexo d</span><br></pre></td></tr></table></figure><h1 id="4-博客自定义功能开发"><a href="#4-博客自定义功能开发" class="headerlink" title="4.博客自定义功能开发"></a>4.博客自定义功能开发</h1><h2 id="4-1生成标签页和分类页"><a href="#4-1生成标签页和分类页" class="headerlink" title="4.1生成标签页和分类页"></a>4.1生成标签页和分类页</h2><p>生成标签页：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure><p>找到 source&#x2F;tags&#x2F;index.md 文件，添加 type: “tags”：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2024-07-05 03:36:02</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">comments: false</span><br><span class="line">top_img: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>生成分类页：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure><p>找到 source&#x2F;categories&#x2F;index.md 文件，添加 type: “categories”：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2024-10-22 03:36:48</span><br><span class="line">aside: false</span><br><span class="line">top_img: false</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h2 id="4-2配置文章模版"><a href="#4-2配置文章模版" class="headerlink" title="4.2配置文章模版"></a>4.2配置文章模版</h2><p>&#x2F;scaffolds 目录下有几个模板文件：</p><p>post.md：新建博文模板<br>page.md：新建标签页模板</p><h3 id="post-md-模板示例"><a href="#post-md-模板示例" class="headerlink" title="post.md 模板示例"></a>post.md 模板示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125; #【必需】页面标题</span><br><span class="line">date: #【必需】页面创建日期</span><br><span class="line">updated: #【可选】页面更新日期</span><br><span class="line">tags: #【可选】文章标签</span><br><span class="line">categories: #【可选】文章分类</span><br><span class="line">keywords: #【可选】文章关键字</span><br><span class="line">description: #【可选】文章描述</span><br><span class="line">top: # 1 置顶</span><br><span class="line">top_img: #【可选】文章顶部图片</span><br><span class="line">comments: #【可选】显示文章评论模块(默认 true)</span><br><span class="line">cover: https://img.090227.xyz/file/ae62475a131f3734a201c.png #【可选】文章缩略图</span><br><span class="line">toc: #【可选】显示文章 TOC</span><br><span class="line">toc_number: #【可选】显示 toc_number</span><br><span class="line">toc_style_simple: #【可选】显示 toc 简洁模式</span><br><span class="line">copyright: #【可选】显示文章版权模块</span><br><span class="line">copyright_author: #【可选】文章版权作者</span><br><span class="line">copyright_author_href: #【可选】作者链接</span><br><span class="line">copyright_url: #【可选】版权链接</span><br><span class="line">copyright_info: #【可选】版权声明文字</span><br><span class="line">mathjax: #【可选】显示 mathjax</span><br><span class="line">katex: #【可选】显示 katex</span><br><span class="line">aplayer: #【可选】加载 aplayer 的 js 和 css</span><br><span class="line">highlight_shrink: #【可选】配置代码框是否展开</span><br><span class="line">aside: #【可选】显示侧边栏 (默认 true)</span><br><span class="line">swiper_index: 10 #【可选】首页轮播图配置</span><br><span class="line">top_group_index: 10 #【可选】首页右侧卡片组配置</span><br><span class="line">ai: #【可选】文章 ai 摘要</span><br><span class="line">background: &quot;#fff&quot; #【可选】文章主色</span><br><span class="line">---</span><br><span class="line">&lt;div class=&quot;video-container&quot;&gt;[视频内嵌代码]&lt;/div&gt;</span><br><span class="line">&lt;style&gt;.video-container &#123; position: relative; padding-top: 56.25%; &#125; .video-container iframe &#123; position: absolute; top: 0; left: 0; width: 100%; height: 100%; &#125;&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="page-md-模板示例"><a href="#page-md-模板示例" class="headerlink" title="page.md 模板示例"></a>page.md 模板示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125; #【必需】页面标题</span><br><span class="line">date: #【必需】页面创建日期</span><br><span class="line">type: #【必需】标签、分类等</span><br><span class="line">updated: #【可选】页面更新日期</span><br><span class="line">comments: #【可选】显示页面评论模块</span><br><span class="line">description: #【可选】页面描述</span><br><span class="line">keywords: #【可选】页面关键字</span><br><span class="line">top_img: https://img.090227.xyz/file/ae62475a131f3734a201c.png #【可选】页面顶部图片</span><br><span class="line">mathjax: #【可选】显示 mathjax</span><br><span class="line">katex: #【可选】显示 katex</span><br><span class="line">aside: #【可选】显示侧边栏 (默认 true)</span><br><span class="line">aplayer: #【可选】加载 aplayer 的 js 和 css</span><br><span class="line">highlight_shrink: #【可选】配置代码框是否展开</span><br><span class="line">top_single_background: #【可选】部分页面的顶部模块背景图片</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h2 id="4-3相关插件"><a href="#4-3相关插件" class="headerlink" title="4.3相关插件"></a>4.3相关插件</h2><h3 id="安装本地搜索插件"><a href="#安装本地搜索插件" class="headerlink" title="安装本地搜索插件"></a>安装本地搜索插件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><p>在配置文件(_config.xxx.yml)中添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  preload: false</span><br><span class="line">  CDN:</span><br></pre></td></tr></table></figure><h3 id="安装文章置顶插件"><a href="#安装文章置顶插件" class="headerlink" title="安装文章置顶插件"></a>安装文章置顶插件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-topindex --save</span><br></pre></td></tr></table></figure><p>在需要置顶的文章中添加 top 参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top: 1</span><br></pre></td></tr></table></figure><p>如果存在多个置顶文章，top 后的参数越大，越靠前。</p><h3 id="安装文章中可插入图片插件"><a href="#安装文章中可插入图片插件" class="headerlink" title="安装文章中可插入图片插件"></a>安装文章中可插入图片插件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-asset-img --save</span><br></pre></td></tr></table></figure><h3 id="安装字数统计插件"><a href="#安装字数统计插件" class="headerlink" title="安装字数统计插件"></a>安装字数统计插件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure><h2 id="4-4评论系统搭建"><a href="#4-4评论系统搭建" class="headerlink" title="4.4评论系统搭建"></a>4.4评论系统搭建</h2><p>如果你想在某个网页或者文章页中使用Valine，请参照以下步骤配置</p><h3 id="获取AppID和AppKey"><a href="#获取AppID和AppKey" class="headerlink" title="获取AppID和AppKey"></a>获取AppID和AppKey</h3><p>1.请先登录或<a href="https://console.leancloud.cn/register">注册</a> LeanCloud, 进入控制台后点击左上角创建应用<br>2.应用创建好以后，进入刚刚创建的应用，选择左边的设置&gt;应用凭证，然后就能看到你的AppID和AppKey了,填入代码中即可</p><h3 id="安装valine插件"><a href="#安装valine插件" class="headerlink" title="安装valine插件"></a>安装valine插件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install valine --save</span><br></pre></td></tr></table></figure><h1 id="5-博客使用"><a href="#5-博客使用" class="headerlink" title="5.博客使用"></a>5.博客使用</h1><p>新建博文命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new 这是一篇新的博文</span><br></pre></td></tr></table></figure><p>部署上线</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//本地预览</span><br><span class="line">hexo cl; hexo s</span><br><span class="line">//推送更新上线</span><br><span class="line">hexo cl; hexo g; hexo d</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在心里种花，人生才不会荒芜。</title>
      <link href="/lief/%E5%9C%A8%E5%BF%83%E9%87%8C%E7%A7%8D%E8%8A%B1%EF%BC%8C%E4%BA%BA%E7%94%9F%E6%89%8D%E4%B8%8D%E4%BC%9A%E8%8D%92%E8%8A%9C%E3%80%82/"/>
      <url>/lief/%E5%9C%A8%E5%BF%83%E9%87%8C%E7%A7%8D%E8%8A%B1%EF%BC%8C%E4%BA%BA%E7%94%9F%E6%89%8D%E4%B8%8D%E4%BC%9A%E8%8D%92%E8%8A%9C%E3%80%82/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 我想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面朝大海，春暖花开！</title>
      <link href="/lief/%E9%9D%A2%E6%9C%9D%E5%A4%A7%E6%B5%B7%EF%BC%8C%E6%98%A5%E6%9A%96%E8%8A%B1%E5%BC%80%EF%BC%81/"/>
      <url>/lief/%E9%9D%A2%E6%9C%9D%E5%A4%A7%E6%B5%B7%EF%BC%8C%E6%98%A5%E6%9A%96%E8%8A%B1%E5%BC%80%EF%BC%81/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 我想 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
