<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>法算day12</title>
      <link href="/lief/%E6%B3%95%E7%AE%97day12/"/>
      <url>/lief/%E6%B3%95%E7%AE%97day12/</url>
      
        <content type="html"><![CDATA[<div class="video-container">[up主专用，视频内嵌代码贴在这]</div><style>.video-container {    position: relative;    width: 100%;    padding-top: 56.25%; /* 16:9 aspect ratio (height/width = 9/16 * 100%) */}.video-container iframe {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;}</style><h1 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h1><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p><ul><li><p>注意：<br>对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。<br>如果 s 中存在这样的子串，我们保证它是唯一的答案。</p></li><li><p>示例 1：<br>输入：s &#x3D; “ADOBECODEBANC”, t &#x3D; “ABC”<br>输出：”BANC”<br>解释：最小覆盖子串 “BANC” 包含来自字符串 t 的 ‘A’、’B’ 和 ‘C’。</p></li><li><p>示例 2：<br>输入：s &#x3D; “a”, t &#x3D; “a”<br>输出：”a”<br>解释：整个字符串 s 是最小覆盖子串。</p></li><li><p>示例 3:<br>输入: s &#x3D; “a”, t &#x3D; “aa”<br>输出: “”<br>解释: t 中两个字符 ‘a’ 均应包含在 s 的子串中，<br>因此没有符合条件的子字符串，返回空字符串。</p></li></ul><p>提示：<br>m &#x3D;&#x3D; s.length<br>n &#x3D;&#x3D; t.length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 105<br>s 和 t 由英文字母组成</p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>这是一个典型的滑动窗口问题，需要在字符串s中找到包含字符串t所有字符的最小子串。算法使用了双指针技巧和哈希表来高效解决这个问题。</p><ol><li>初始化阶段<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">need_dict = defaultdict(int)  # 记录t中每个字符的出现次数</span><br><span class="line">window_dict = defaultdict(int)  # 记录当前窗口中每个字符的出现次数</span><br></pre></td></tr></table></figure></li></ol><ul><li>need_dict：统计目标字符串t中每个字符的出现频率</li><li>window_dict：统计当前滑动窗口中每个字符的出现频率</li></ul><ol start="2"><li>滑动窗口过程<br>算法通过两个指针left和right维护一个滑动窗口：</li></ol><ul><li>扩展窗口（右指针移动）：<br>  右指针向右移动，将新字符加入窗口<br>  更新窗口字符计数<br>  如果当前字符在t中，并且窗口中该字符的数量等于t中该字符的数量，则增加有效计数valid</li><li>收缩窗口（左指针移动）：<br>  当窗口包含t的所有字符时（valid &#x3D;&#x3D; len(need_dict)）<br>  尝试收缩左指针，寻找更小的满足条件的窗口<br>  更新最小窗口记录<br>  如果移出的字符在t中，更新窗口计数和有效计数</li></ul><ol start="3"><li>终止条件</li></ol><ul><li>右指针遍历完整个字符串s</li><li>返回找到的最小窗口子串</li></ul><h3 id="算法关键点"><a href="#算法关键点" class="headerlink" title="算法关键点"></a>算法关键点</h3><ol><li><p>滑动窗口策略：<br>右指针扩展窗口，直到包含t的所有字符<br>左指针收缩窗口，寻找最小满足条件的窗口</p></li><li><p>有效计数机制：<br>只有当窗口中某个字符的数量恰好等于t中该字符的数量时，才增加valid<br>这确保了valid准确反映窗口是否包含t的所有字符</p></li><li><p>最小窗口更新：<br>每次找到满足条件的窗口时，记录并更新最小窗口<br>通过收缩窗口寻找更小的满足条件的窗口</p></li></ol><h3 id="python版"><a href="#python版" class="headerlink" title="python版"></a>python版</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">from collections import defaultdict</span><br><span class="line"></span><br><span class="line">def minWindow(s, t):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    找到s中涵盖t所有字符的最小子串</span><br><span class="line">    </span><br><span class="line">    参数:</span><br><span class="line">        s: 主字符串</span><br><span class="line">        t: 目标字符串</span><br><span class="line">        </span><br><span class="line">    返回:</span><br><span class="line">        str: 最小覆盖子串，如果不存在则返回空字符串</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 如果s或t为空，或者s的长度小于t的长度，直接返回空字符串</span><br><span class="line">    if not s or not t or len(s) &lt; len(t):</span><br><span class="line">        return &quot;&quot;</span><br><span class="line">    </span><br><span class="line">    # 使用defaultdict记录t中每个字符的出现次数</span><br><span class="line">    need_dict = defaultdict(int)</span><br><span class="line">    for char in t:</span><br><span class="line">        need_dict[char] += 1</span><br><span class="line">    </span><br><span class="line">    # 使用defaultdict记录当前窗口中每个字符的出现次数</span><br><span class="line">    window_dict = defaultdict(int)</span><br><span class="line">    </span><br><span class="line">    # 初始化左右指针、有效字符计数、最小窗口的起始位置和长度</span><br><span class="line">    left = 0</span><br><span class="line">    right = 0</span><br><span class="line">    valid = 0  # 记录窗口中满足need_dict要求的字符数量</span><br><span class="line">    start = 0  # 最小窗口的起始位置</span><br><span class="line">    min_len = float(&#x27;inf&#x27;)  # 最小窗口长度，初始化为无穷大</span><br><span class="line">    </span><br><span class="line">    # 滑动窗口，右指针遍历整个字符串s</span><br><span class="line">    while right &lt; len(s):</span><br><span class="line">        # 获取右指针指向的字符</span><br><span class="line">        c = s[right]</span><br><span class="line">        # 右指针向右移动</span><br><span class="line">        right += 1</span><br><span class="line">        </span><br><span class="line">        # 如果当前字符在t中，则更新窗口计数</span><br><span class="line">        if c in need_dict:</span><br><span class="line">            window_dict[c] += 1</span><br><span class="line">            # 如果窗口中该字符的数量等于t中该字符的数量，则有效计数加1</span><br><span class="line">            if window_dict[c] == need_dict[c]:</span><br><span class="line">                valid += 1</span><br><span class="line">        </span><br><span class="line">        # 当窗口中包含t的所有字符时，尝试收缩左指针</span><br><span class="line">        while valid == len(need_dict):</span><br><span class="line">            # 更新最小窗口</span><br><span class="line">            if right - left &lt; min_len:</span><br><span class="line">                start = left</span><br><span class="line">                min_len = right - left</span><br><span class="line">            </span><br><span class="line">            # 获取左指针指向的字符</span><br><span class="line">            d = s[left]</span><br><span class="line">            # 左指针向右移动</span><br><span class="line">            left += 1</span><br><span class="line">            </span><br><span class="line">            # 如果移出的字符在t中，则更新窗口计数</span><br><span class="line">            if d in need_dict:</span><br><span class="line">                # 如果窗口中该字符的数量等于t中该字符的数量，则有效计数减1</span><br><span class="line">                if window_dict[d] == need_dict[d]:</span><br><span class="line">                    valid -= 1</span><br><span class="line">                window_dict[d] -= 1</span><br><span class="line">    </span><br><span class="line">    # 如果找到了最小窗口，返回对应的子串，否则返回空字符串</span><br><span class="line">    return &quot;&quot; if min_len == float(&#x27;inf&#x27;) else s[start:start + min_len]</span><br><span class="line"></span><br><span class="line"># 测试代码</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    # 示例1</span><br><span class="line">    s1 = &quot;ADOBECODEBANC&quot;</span><br><span class="line">    t1 = &quot;ABC&quot;</span><br><span class="line">    print(f&quot;输入: s = &#x27;&#123;s1&#125;&#x27;, t = &#x27;&#123;t1&#125;&#x27;&quot;)</span><br><span class="line">    print(f&quot;输出: &#x27;&#123;minWindow(s1, t1)&#125;&#x27;&quot;)  # 输出: &quot;BANC&quot;</span><br><span class="line">    </span><br><span class="line">    # 示例2</span><br><span class="line">    s2 = &quot;a&quot;</span><br><span class="line">    t2 = &quot;a&quot;</span><br><span class="line">    print(f&quot;输入: s = &#x27;&#123;s2&#125;&#x27;, t = &#x27;&#123;t2&#125;&#x27;&quot;)</span><br><span class="line">    print(f&quot;输出: &#x27;&#123;minWindow(s2, t2)&#125;&#x27;&quot;)  # 输出: &quot;a&quot;</span><br><span class="line">    </span><br><span class="line">    # 示例3</span><br><span class="line">    s3 = &quot;a&quot;</span><br><span class="line">    t3 = &quot;aa&quot;</span><br><span class="line">    print(f&quot;输入: s = &#x27;&#123;s3&#125;&#x27;, t = &#x27;&#123;t3&#125;&#x27;&quot;)</span><br><span class="line">    print(f&quot;输出: &#x27;&#123;minWindow(s3, t3)&#125;&#x27;&quot;)  # 输出: &quot;&quot;</span><br></pre></td></tr></table></figure><p>✅ 说明：</p><ul><li>时间复杂度：O(n)，其中n是字符串s的长度</li><li>空间复杂度：O(m)，其中m是字符集的大小</li></ul><h3 id="举例说明s-“ADOBECODEBANC”；t-“ABC”"><a href="#举例说明s-“ADOBECODEBANC”；t-“ABC”" class="headerlink" title="举例说明s &#x3D; “ADOBECODEBANC”；t &#x3D; “ABC”"></a>举例说明s &#x3D; “ADOBECODEBANC”；t &#x3D; “ABC”</h3><ul><li>初始状态<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s: A D O B E C O D E B A N C</span><br><span class="line">t: A B C</span><br><span class="line"></span><br><span class="line">need_dict: &#123;&#x27;A&#x27;:1, &#x27;B&#x27;:1, &#x27;C&#x27;:1&#125;</span><br><span class="line">window_dict: &#123;&#125;</span><br><span class="line">left = 0, right = 0</span><br><span class="line">valid = 0</span><br><span class="line">min_len = ∞, start = 0</span><br></pre></td></tr></table></figure></li><li>步骤1：right&#x3D;0, char&#x3D;’A’<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">当前窗口: [A]</span><br><span class="line">操作:</span><br><span class="line">- A在need_dict中</span><br><span class="line">- window_dict[&#x27;A&#x27;] = 1</span><br><span class="line">- window_dict[&#x27;A&#x27;] == need_dict[&#x27;A&#x27;] (1==1) → valid=1</span><br><span class="line">状态:</span><br><span class="line">  window_dict: &#123;&#x27;A&#x27;:1&#125;</span><br><span class="line">  valid = 1 (A满足要求)</span><br><span class="line">  不满足条件(valid=1 &lt; 3)，继续扩展</span><br></pre></td></tr></table></figure></li><li>步骤2：right&#x3D;1, char&#x3D;’D’<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">当前窗口: [A D]</span><br><span class="line">操作:</span><br><span class="line">- D不在need_dict中，跳过</span><br><span class="line">状态:</span><br><span class="line">  window_dict: &#123;&#x27;A&#x27;:1&#125;</span><br><span class="line">  valid = 1</span><br><span class="line">  不满足条件，继续扩展</span><br></pre></td></tr></table></figure></li><li>步骤3：right&#x3D;2, char&#x3D;’O’<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">当前窗口: [A D O]</span><br><span class="line">操作:</span><br><span class="line">- O不在need_dict中，跳过</span><br><span class="line">状态:</span><br><span class="line">  window_dict: &#123;&#x27;A&#x27;:1&#125;</span><br><span class="line">  valid = 1</span><br><span class="line">  不满足条件，继续扩展</span><br></pre></td></tr></table></figure></li><li>步骤4：right&#x3D;3, char&#x3D;’B’<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">当前窗口: [A D O B]</span><br><span class="line">操作:</span><br><span class="line">- B在need_dict中</span><br><span class="line">- window_dict[&#x27;B&#x27;] = 1</span><br><span class="line">- window_dict[&#x27;B&#x27;] == need_dict[&#x27;B&#x27;] (1==1) → valid=2</span><br><span class="line">状态:</span><br><span class="line">  window_dict: &#123;&#x27;A&#x27;:1, &#x27;B&#x27;:1&#125;</span><br><span class="line">  valid = 2 (A和B满足要求)</span><br><span class="line">  不满足条件(valid=2 &lt; 3)，继续扩展</span><br></pre></td></tr></table></figure></li><li>步骤5：right&#x3D;4, char&#x3D;’E’<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">当前窗口: [A D O B E]</span><br><span class="line">操作:</span><br><span class="line">- E不在need_dict中，跳过</span><br><span class="line">状态:</span><br><span class="line">  window_dict: &#123;&#x27;A&#x27;:1, &#x27;B&#x27;:1&#125;</span><br><span class="line">  valid = 2</span><br><span class="line">  不满足条件，继续扩展</span><br></pre></td></tr></table></figure></li><li>步骤6：right&#x3D;5, char&#x3D;’C’<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">当前窗口: [A D O B E C]</span><br><span class="line">操作:</span><br><span class="line">- C在need_dict中</span><br><span class="line">- window_dict[&#x27;C&#x27;] = 1</span><br><span class="line">- window_dict[&#x27;C&#x27;] == need_dict[&#x27;C&#x27;] (1==1) → valid=3</span><br><span class="line">状态:</span><br><span class="line">  window_dict: &#123;&#x27;A&#x27;:1, &#x27;B&#x27;:1, &#x27;C&#x27;:1&#125;</span><br><span class="line">  valid = 3 (A、B、C都满足要求)</span><br><span class="line">  满足条件(valid=3 == 3)，开始收缩窗口</span><br><span class="line">  </span><br><span class="line">  // 收缩窗口</span><br><span class="line">  当前窗口长度: 6-0=6</span><br><span class="line">  更新最小窗口: min_len=6, start=0</span><br><span class="line">  </span><br><span class="line">  移除left=0的字符&#x27;A&#x27;:</span><br><span class="line">  - A在need_dict中</span><br><span class="line">  - window_dict[&#x27;A&#x27;] == need_dict[&#x27;A&#x27;] (1==1) → valid=2</span><br><span class="line">  - window_dict[&#x27;A&#x27;] = 0</span><br><span class="line">  </span><br><span class="line">  状态:</span><br><span class="line">    window_dict: &#123;&#x27;A&#x27;:0, &#x27;B&#x27;:1, &#x27;C&#x27;:1&#125;</span><br><span class="line">    valid = 2</span><br><span class="line">    不满足条件，停止收缩</span><br></pre></td></tr></table></figure></li><li>步骤7：right&#x3D;6, char&#x3D;’O’<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">当前窗口: [D O B E C O]</span><br><span class="line">操作:</span><br><span class="line">- O不在need_dict中，跳过</span><br><span class="line">状态:</span><br><span class="line">  window_dict: &#123;&#x27;A&#x27;:0, &#x27;B&#x27;:1, &#x27;C&#x27;:1&#125;</span><br><span class="line">  valid = 2</span><br><span class="line">  不满足条件，继续扩展</span><br></pre></td></tr></table></figure></li><li>步骤8：right&#x3D;7, char&#x3D;’D’<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">当前窗口: [D O B E C O D]</span><br><span class="line">操作:</span><br><span class="line">- D不在need_dict中，跳过</span><br><span class="line">状态:</span><br><span class="line">  window_dict: &#123;&#x27;A&#x27;:0, &#x27;B&#x27;:1, &#x27;C&#x27;:1&#125;</span><br><span class="line">  valid = 2</span><br><span class="line">  不满足条件，继续扩展</span><br></pre></td></tr></table></figure></li><li>步骤9：right&#x3D;8, char&#x3D;’E’<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">当前窗口: [D O B E C O D E]</span><br><span class="line">操作:</span><br><span class="line">- E不在need_dict中，跳过</span><br><span class="line">状态:</span><br><span class="line">  window_dict: &#123;&#x27;A&#x27;:0, &#x27;B&#x27;:1, &#x27;C&#x27;:1&#125;</span><br><span class="line">  valid = 2</span><br><span class="line">  不满足条件，继续扩展</span><br></pre></td></tr></table></figure></li><li>步骤10：right&#x3D;9, char&#x3D;’B’<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">当前窗口: [D O B E C O D E B]</span><br><span class="line">操作:</span><br><span class="line">- B在need_dict中</span><br><span class="line">- window_dict[&#x27;B&#x27;] = 2</span><br><span class="line">- window_dict[&#x27;B&#x27;] &gt; need_dict[&#x27;B&#x27;] (2&gt;1)，valid不变</span><br><span class="line">状态:</span><br><span class="line">  window_dict: &#123;&#x27;A&#x27;:0, &#x27;B&#x27;:2, &#x27;C&#x27;:1&#125;</span><br><span class="line">  valid = 2</span><br><span class="line">  不满足条件，继续扩展</span><br></pre></td></tr></table></figure></li><li>步骤11：right&#x3D;10, char&#x3D;’A’<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">当前窗口: [D O B E C O D E B A]</span><br><span class="line">操作:</span><br><span class="line">- A在need_dict中</span><br><span class="line">- window_dict[&#x27;A&#x27;] = 1</span><br><span class="line">- window_dict[&#x27;A&#x27;] == need_dict[&#x27;A&#x27;] (1==1) → valid=3</span><br><span class="line">状态:</span><br><span class="line">  window_dict: &#123;&#x27;A&#x27;:1, &#x27;B&#x27;:2, &#x27;C&#x27;:1&#125;</span><br><span class="line">  valid = 3 (A、B、C都满足要求)</span><br><span class="line">  满足条件，开始收缩窗口</span><br><span class="line">  </span><br><span class="line">  // 收缩窗口</span><br><span class="line">  当前窗口长度: 11-1=10</span><br><span class="line">  10 &gt; min_len=6，不更新最小窗口</span><br><span class="line">  </span><br><span class="line">  移除left=1的字符&#x27;D&#x27;:</span><br><span class="line">  - D不在need_dict中，跳过</span><br><span class="line">  </span><br><span class="line">  状态:</span><br><span class="line">    window_dict: &#123;&#x27;A&#x27;:1, &#x27;B&#x27;:2, &#x27;C&#x27;:1&#125;</span><br><span class="line">    valid = 3</span><br><span class="line">    满足条件，继续收缩</span><br><span class="line">    </span><br><span class="line">  当前窗口长度: 11-2=9</span><br><span class="line">  9 &gt; min_len=6，不更新最小窗口</span><br><span class="line">  </span><br><span class="line">  移除left=2的字符&#x27;O&#x27;:</span><br><span class="line">  - O不在need_dict中，跳过</span><br><span class="line">  </span><br><span class="line">  状态:</span><br><span class="line">    window_dict: &#123;&#x27;A&#x27;:1, &#x27;B&#x27;:2, &#x27;C&#x27;:1&#125;</span><br><span class="line">    valid = 3</span><br><span class="line">    满足条件，继续收缩</span><br><span class="line">    </span><br><span class="line">  当前窗口长度: 11-3=8</span><br><span class="line">  8 &gt; min_len=6，不更新最小窗口</span><br><span class="line">  </span><br><span class="line">  移除left=3的字符&#x27;B&#x27;:</span><br><span class="line">  - B在need_dict中</span><br><span class="line">  - window_dict[&#x27;B&#x27;] = 1</span><br><span class="line">  - window_dict[&#x27;B&#x27;] == need_dict[&#x27;B&#x27;] (1==1)，valid不变</span><br><span class="line">  - window_dict[&#x27;B&#x27;] = 1</span><br><span class="line">  </span><br><span class="line">  状态:</span><br><span class="line">    window_dict: &#123;&#x27;A&#x27;:1, &#x27;B&#x27;:1, &#x27;C&#x27;:1&#125;</span><br><span class="line">    valid = 3</span><br><span class="line">    满足条件，继续收缩</span><br><span class="line">    </span><br><span class="line">  当前窗口长度: 11-4=7</span><br><span class="line">  7 &gt; min_len=6，不更新最小窗口</span><br><span class="line">  </span><br><span class="line">  移除left=4的字符&#x27;E&#x27;:</span><br><span class="line">  - E不在need_dict中，跳过</span><br><span class="line">  </span><br><span class="line">  状态:</span><br><span class="line">    window_dict: &#123;&#x27;A&#x27;:1, &#x27;B&#x27;:1, &#x27;C&#x27;:1&#125;</span><br><span class="line">    valid = 3</span><br><span class="line">    满足条件，继续收缩</span><br><span class="line">    </span><br><span class="line">  当前窗口长度: 11-5=6</span><br><span class="line">  6 == min_len=6，不更新最小窗口</span><br><span class="line">  </span><br><span class="line">  移除left=5的字符&#x27;C&#x27;:</span><br><span class="line">  - C在need_dict中</span><br><span class="line">  - window_dict[&#x27;C&#x27;] == need_dict[&#x27;C&#x27;] (1==1) → valid=2</span><br><span class="line">  - window_dict[&#x27;C&#x27;] = 0</span><br><span class="line">  </span><br><span class="line">  状态:</span><br><span class="line">    window_dict: &#123;&#x27;A&#x27;:1, &#x27;B&#x27;:1, &#x27;C&#x27;:0&#125;</span><br><span class="line">    valid = 2</span><br><span class="line">    不满足条件，停止收缩</span><br></pre></td></tr></table></figure></li><li>步骤12：right&#x3D;11, char&#x3D;’N’<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">当前窗口: [O D E B A N]</span><br><span class="line">操作:</span><br><span class="line">- N不在need_dict中，跳过</span><br><span class="line">状态:</span><br><span class="line">  window_dict: &#123;&#x27;A&#x27;:1, &#x27;B&#x27;:1, &#x27;C&#x27;:0&#125;</span><br><span class="line">  valid = 2</span><br><span class="line">  不满足条件，继续扩展</span><br></pre></td></tr></table></figure></li><li>步骤13：right&#x3D;12, char&#x3D;’C’<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">当前窗口: [O D E B A N C]</span><br><span class="line">操作:</span><br><span class="line">- C在need_dict中</span><br><span class="line">- window_dict[&#x27;C&#x27;] = 1</span><br><span class="line">- window_dict[&#x27;C&#x27;] == need_dict[&#x27;C&#x27;] (1==1) → valid=3</span><br><span class="line">状态:</span><br><span class="line">  window_dict: &#123;&#x27;A&#x27;:1, &#x27;B&#x27;:1, &#x27;C&#x27;:1&#125;</span><br><span class="line">  valid = 3 (A、B、C都满足要求)</span><br><span class="line">  满足条件，开始收缩窗口</span><br><span class="line">  </span><br><span class="line">  // 收缩窗口</span><br><span class="line">  当前窗口长度: 13-6=7</span><br><span class="line">  7 &gt; min_len=6，不更新最小窗口</span><br><span class="line">  </span><br><span class="line">  移除left=6的字符&#x27;O&#x27;:</span><br><span class="line">  - O不在need_dict中，跳过</span><br><span class="line">  </span><br><span class="line">  状态:</span><br><span class="line">    window_dict: &#123;&#x27;A&#x27;:1, &#x27;B&#x27;:1, &#x27;C&#x27;:1&#125;</span><br><span class="line">    valid = 3</span><br><span class="line">    满足条件，继续收缩</span><br><span class="line">    </span><br><span class="line">  当前窗口长度: 13-7=6</span><br><span class="line">  6 == min_len=6，不更新最小窗口</span><br><span class="line">  </span><br><span class="line">  移除left=7的字符&#x27;D&#x27;:</span><br><span class="line">  - D不在need_dict中，跳过</span><br><span class="line">  </span><br><span class="line">  状态:</span><br><span class="line">    window_dict: &#123;&#x27;A&#x27;:1, &#x27;B&#x27;:1, &#x27;C&#x27;:1&#125;</span><br><span class="line">    valid = 3</span><br><span class="line">    满足条件，继续收缩</span><br><span class="line">    </span><br><span class="line">  当前窗口长度: 13-8=5</span><br><span class="line">  5 &lt; min_len=6，更新最小窗口: min_len=5, start=8</span><br><span class="line">  </span><br><span class="line">  移除left=8的字符&#x27;E&#x27;:</span><br><span class="line">  - E不在need_dict中，跳过</span><br><span class="line">  </span><br><span class="line">  状态:</span><br><span class="line">    window_dict: &#123;&#x27;A&#x27;:1, &#x27;B&#x27;:1, &#x27;C&#x27;:1&#125;</span><br><span class="line">    valid = 3</span><br><span class="line">    满足条件，继续收缩</span><br><span class="line">    </span><br><span class="line">  当前窗口长度: 13-9=4</span><br><span class="line">  4 &lt; min_len=5，更新最小窗口: min_len=4, start=9</span><br><span class="line">  </span><br><span class="line">  移除left=9的字符&#x27;B&#x27;:</span><br><span class="line">  - B在need_dict中</span><br><span class="line">  - window_dict[&#x27;B&#x27;] == need_dict[&#x27;B&#x27;] (1==1) → valid=2</span><br><span class="line">  - window_dict[&#x27;B&#x27;] = 0</span><br><span class="line">  </span><br><span class="line">  状态:</span><br><span class="line">    window_dict: &#123;&#x27;A&#x27;:1, &#x27;B&#x27;:0, &#x27;C&#x27;:1&#125;</span><br><span class="line">    valid = 2</span><br><span class="line">    不满足条件，停止收缩</span><br></pre></td></tr></table></figure></li><li>最终结果<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">最小窗口: s[9:9+4] = &quot;BANC&quot;</span><br><span class="line">返回结果: &quot;BANC&quot;</span><br></pre></td></tr></table></figure></li></ul><h3 id="java版"><a href="#java版" class="headerlink" title="java版"></a>java版</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class MinimumWindowSubstring &#123;</span><br><span class="line">    </span><br><span class="line">    public static String minWindow(String s, String t) &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 找到s中涵盖t所有字符的最小子串</span><br><span class="line">         * </span><br><span class="line">         * @param s 主字符串</span><br><span class="line">         * @param t 目标字符串</span><br><span class="line">         * @return 最小覆盖子串，如果不存在则返回空字符串</span><br><span class="line">         */</span><br><span class="line">        </span><br><span class="line">        // 边界情况检查：如果s或t为空，或者s的长度小于t的长度，直接返回空字符串</span><br><span class="line">        if (s == null || t == null || s.length() == 0 || t.length() == 0 || s.length() &lt; t.length()) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 使用HashMap记录t中每个字符的出现次数</span><br><span class="line">        Map&lt;Character, Integer&gt; needMap = new HashMap&lt;&gt;();</span><br><span class="line">        for (char c : t.toCharArray()) &#123;</span><br><span class="line">            needMap.put(c, needMap.getOrDefault(c, 0) + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 使用HashMap记录当前窗口中每个字符的出现次数</span><br><span class="line">        Map&lt;Character, Integer&gt; windowMap = new HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        // 初始化左右指针、有效字符计数、最小窗口的起始位置和长度</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = 0;</span><br><span class="line">        int valid = 0; // 记录窗口中满足needMap要求的字符数量</span><br><span class="line">        int start = 0; // 最小窗口的起始位置</span><br><span class="line">        int minLen = Integer.MAX_VALUE; // 最小窗口长度，初始化为最大整数</span><br><span class="line">        </span><br><span class="line">        // 滑动窗口，右指针遍历整个字符串s</span><br><span class="line">        while (right &lt; s.length()) &#123;</span><br><span class="line">            // 获取右指针指向的字符</span><br><span class="line">            char c = s.charAt(right);</span><br><span class="line">            // 右指针向右移动</span><br><span class="line">            right++;</span><br><span class="line">            </span><br><span class="line">            // 如果当前字符在t中，则更新窗口计数</span><br><span class="line">            if (needMap.containsKey(c)) &#123;</span><br><span class="line">                windowMap.put(c, windowMap.getOrDefault(c, 0) + 1);</span><br><span class="line">                // 如果窗口中该字符的数量等于t中该字符的数量，则有效计数加1</span><br><span class="line">                if (windowMap.get(c).equals(needMap.get(c))) &#123;</span><br><span class="line">                    valid++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 当窗口中包含t的所有字符时，尝试收缩左指针</span><br><span class="line">            while (valid == needMap.size()) &#123;</span><br><span class="line">                // 更新最小窗口</span><br><span class="line">                if (right - left &lt; minLen) &#123;</span><br><span class="line">                    start = left;</span><br><span class="line">                    minLen = right - left;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                // 获取左指针指向的字符</span><br><span class="line">                char d = s.charAt(left);</span><br><span class="line">                // 左指针向右移动</span><br><span class="line">                left++;</span><br><span class="line">                </span><br><span class="line">                // 如果移出的字符在t中，则更新窗口计数</span><br><span class="line">                if (needMap.containsKey(d)) &#123;</span><br><span class="line">                    // 如果窗口中该字符的数量等于t中该字符的数量，则有效计数减1</span><br><span class="line">                    if (windowMap.get(d).equals(needMap.get(d))) &#123;</span><br><span class="line">                        valid--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    windowMap.put(d, windowMap.get(d) - 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 如果找到了最小窗口，返回对应的子串，否则返回空字符串</span><br><span class="line">        return minLen == Integer.MAX_VALUE ? &quot;&quot; : s.substring(start, start + minLen);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 测试代码</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 示例1</span><br><span class="line">        String s1 = &quot;ADOBECODEBANC&quot;;</span><br><span class="line">        String t1 = &quot;ABC&quot;;</span><br><span class="line">        System.out.println(&quot;输入: s = \&quot;&quot; + s1 + &quot;\&quot;, t = \&quot;&quot; + t1 + &quot;\&quot;&quot;);</span><br><span class="line">        System.out.println(&quot;输出: \&quot;&quot; + minWindow(s1, t1) + &quot;\&quot;&quot;); // 输出: &quot;BANC&quot;</span><br><span class="line">        </span><br><span class="line">        // 示例2</span><br><span class="line">        String s2 = &quot;a&quot;;</span><br><span class="line">        String t2 = &quot;a&quot;;</span><br><span class="line">        System.out.println(&quot;输入: s = \&quot;&quot; + s2 + &quot;\&quot;, t = \&quot;&quot; + t2 + &quot;\&quot;&quot;);</span><br><span class="line">        System.out.println(&quot;输出: \&quot;&quot; + minWindow(s2, t2) + &quot;\&quot;&quot;); // 输出: &quot;a&quot;</span><br><span class="line">        </span><br><span class="line">        // 示例3</span><br><span class="line">        String s3 = &quot;a&quot;;</span><br><span class="line">        String t3 = &quot;aa&quot;;</span><br><span class="line">        System.out.println(&quot;输入: s = \&quot;&quot; + s3 + &quot;\&quot;, t = \&quot;&quot; + t3 + &quot;\&quot;&quot;);</span><br><span class="line">        System.out.println(&quot;输出: \&quot;&quot; + minWindow(s3, t3) + &quot;\&quot;&quot;); // 输出: &quot;&quot;</span><br><span class="line">        </span><br><span class="line">        // 额外测试用例</span><br><span class="line">        String s4 = &quot;aa&quot;;</span><br><span class="line">        String t4 = &quot;aa&quot;;</span><br><span class="line">        System.out.println(&quot;输入: s = \&quot;&quot; + s4 + &quot;\&quot;, t = \&quot;&quot; + t4 + &quot;\&quot;&quot;);</span><br><span class="line">        System.out.println(&quot;输出: \&quot;&quot; + minWindow(s4, t4) + &quot;\&quot;&quot;); // 输出: &quot;aa&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>法算day11</title>
      <link href="/lief/%E6%B3%95%E7%AE%97day11/"/>
      <url>/lief/%E6%B3%95%E7%AE%97day11/</url>
      
        <content type="html"><![CDATA[<div class="video-container">[up主专用，视频内嵌代码贴在这]</div><style>.video-container {    position: relative;    width: 100%;    padding-top: 56.25%; /* 16:9 aspect ratio (height/width = 9/16 * 100%) */}.video-container iframe {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;}</style><h1 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h1><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。<br>返回 滑动窗口中的最大值 。</p><ul><li><p>示例 1：<br>输入：nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3<br>输出：[3,3,5,5,6,7]<br>解释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure></li><li><p>示例 2：<br>输入：nums &#x3D; [1], k &#x3D; 1<br>输出：[1]</p></li></ul><p>提示：<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104<br>1 &lt;&#x3D; k &lt;&#x3D; nums.length</p><h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>这个算法使用双端队列（Deque）来高效地找到每个滑动窗口的最大值：</p><ol><li>队列中存储的是数组元素的索引，而不是元素值本身</li><li>队列中的索引对应的元素值是递减的</li><li>队列头部始终是当前窗口的最大值的索引</li></ol><h3 id="语法解析"><a href="#语法解析" class="headerlink" title="语法解析"></a>语法解析</h3><p><code>Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();</code></p><ul><li>Deque<Integer>: 接口类型声明，表示这是一个双端队列，存储整数类型</li><li>deque: 变量名</li><li>new LinkedList&lt;&gt;(): 创建LinkedList类的实例作为Deque的实现</li><li><Integer>: 泛型，指定队列中存储的元素类型为整数</li></ul><h3 id="实际内存结构"><a href="#实际内存结构" class="headerlink" title="实际内存结构"></a>实际内存结构</h3><ul><li>在内存中，LinkedList 实现的Deque大致如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deque → [头节点] ↔ [节点1] ↔ [节点2] ↔ ... ↔ [尾节点]</span><br><span class="line">          ↓          ↓          ↓               ↓</span><br><span class="line">          索引        索引       索引           索引</span><br></pre></td></tr></table></figure></li></ul><h3 id="Deque的常用方法"><a href="#Deque的常用方法" class="headerlink" title="Deque的常用方法"></a>Deque的常用方法</h3><ul><li>队首操作<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">deque.addFirst(element);    // 在队首添加元素</span><br><span class="line">deque.offerFirst(element);  // 在队首添加元素（推荐）</span><br><span class="line">deque.removeFirst();        // 移除并返回队首元素</span><br><span class="line">deque.pollFirst();          // 移除并返回队首元素（推荐）</span><br><span class="line">deque.getFirst();           // 获取队首元素（不移除）</span><br><span class="line">deque.peekFirst();          // 获取队首元素（不移除，推荐）</span><br></pre></td></tr></table></figure></li><li>队尾操作<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">deque.addLast(element);     // 在队尾添加元素</span><br><span class="line">deque.offerLast(element);   // 在队尾添加元素（推荐）</span><br><span class="line">deque.removeLast();         // 移除并返回队尾元素</span><br><span class="line">deque.pollLast();           // 移除并返回队尾元素（推荐）</span><br><span class="line">deque.getLast();            // 获取队尾元素（不移除）</span><br><span class="line">deque.peekLast();           // 获取队尾元素（不移除，推荐）</span><br></pre></td></tr></table></figure></li></ul><h3 id="java版"><a href="#java版" class="headerlink" title="java版"></a>java版</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class SlidingWindowMaximum &#123;</span><br><span class="line">    public int[] maxSlidingWindow(int[] nums, int k) &#123;</span><br><span class="line">        // 如果数组为空或k为0，直接返回空数组</span><br><span class="line">        if (nums == null || nums.length == 0 || k == 0) &#123;</span><br><span class="line">            return new int[0];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 结果数组的长度是 nums.length - k + 1</span><br><span class="line">        int[] result = new int[nums.length - k + 1];</span><br><span class="line">        // 使用双端队列来存储索引，队列中的索引对应的值是递减的</span><br><span class="line">        Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        // 遍历数组</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            // 移除队列中不在当前窗口范围内的索引</span><br><span class="line">            // 窗口范围是 [i-k+1, i]，所以索引小于 i-k+1 的元素都不在窗口内</span><br><span class="line">            while (!deque.isEmpty() &amp;&amp; deque.peekFirst() &lt; i - k + 1) &#123;</span><br><span class="line">                deque.pollFirst(); // 从队首移除</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 移除队列中所有小于当前元素的索引</span><br><span class="line">            // 因为这些元素不可能是当前窗口或未来窗口的最大值</span><br><span class="line">            while (!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i]) &#123;</span><br><span class="line">                deque.pollLast(); // 从队尾移除</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 将当前元素的索引添加到队列尾部</span><br><span class="line">            deque.offerLast(i);</span><br><span class="line">            </span><br><span class="line">            // 当窗口形成时（即i &gt;= k-1），将当前窗口的最大值添加到结果数组中</span><br><span class="line">            // 当前窗口的最大值就是队列头部的索引对应的元素</span><br><span class="line">            if (i &gt;= k - 1) &#123;</span><br><span class="line">                result[i - k + 1] = nums[deque.peekFirst()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 测试代码</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SlidingWindowMaximum solution = new SlidingWindowMaximum();</span><br><span class="line">        </span><br><span class="line">        // 示例1</span><br><span class="line">        int[] nums1 = &#123;1, 3, -1, -3, 5, 3, 6, 7&#125;;</span><br><span class="line">        int k1 = 3;</span><br><span class="line">        int[] result1 = solution.maxSlidingWindow(nums1, k1);</span><br><span class="line">        System.out.println(&quot;输入: nums = [1,3,-1,-3,5,3,6,7], k = 3&quot;);</span><br><span class="line">        System.out.print(&quot;输出: &quot;);</span><br><span class="line">        System.out.println(Arrays.toString(result1)); // 输出: [3,3,5,5,6,7]</span><br><span class="line">        </span><br><span class="line">        // 示例2</span><br><span class="line">        int[] nums2 = &#123;1&#125;;</span><br><span class="line">        int k2 = 1;</span><br><span class="line">        int[] result2 = solution.maxSlidingWindow(nums2, k2);</span><br><span class="line">        System.out.println(&quot;输入: nums = [1], k = 1&quot;);</span><br><span class="line">        System.out.print(&quot;输出: &quot;);</span><br><span class="line">        System.out.println(Arrays.toString(result2)); // 输出: [1]</span><br><span class="line">        </span><br><span class="line">        // 额外测试用例</span><br><span class="line">        int[] nums3 = &#123;1, -1&#125;;</span><br><span class="line">        int k3 = 1;</span><br><span class="line">        int[] result3 = solution.maxSlidingWindow(nums3, k3);</span><br><span class="line">        System.out.println(&quot;输入: nums = [1,-1], k = 1&quot;);</span><br><span class="line">        System.out.print(&quot;输出: &quot;);</span><br><span class="line">        System.out.println(Arrays.toString(result3)); // 输出: [1,-1]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ 说明：</p><ul><li>时间复杂度O(n)</li><li>空间复杂度O(k)</li></ul><h3 id="滑动窗口移除逻辑详细示例说明nums1-1-3-1-3-5-3-6-7-k1-3"><a href="#滑动窗口移除逻辑详细示例说明nums1-1-3-1-3-5-3-6-7-k1-3" class="headerlink" title="滑动窗口移除逻辑详细示例说明nums1 &#x3D; {1, 3, -1, -3, 5, 3, 6, 7};k1 &#x3D; 3;"></a>滑动窗口移除逻辑详细示例说明nums1 &#x3D; {1, 3, -1, -3, 5, 3, 6, 7};k1 &#x3D; 3;</h3><ul><li><p>初始状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">队列 dq: [] (空)</span><br><span class="line">结果 result: []</span><br></pre></td></tr></table></figure></li><li><p>步骤1: i&#x3D;0, nums[0]&#x3D;1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">当前元素: 1</span><br><span class="line">窗口: [1] (大小不足k，不记录结果)</span><br><span class="line"></span><br><span class="line">操作:</span><br><span class="line">1. 队列为空，直接添加索引0</span><br><span class="line">2. dq = [0] → 对应值 [1]</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">- 队列中只有一个元素，所以它自然是当前窗口的最大值</span><br><span class="line">- 但窗口大小不足k，所以不记录结果</span><br></pre></td></tr></table></figure></li><li><p>步骤2: i&#x3D;1, nums[1]&#x3D;3</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">当前元素: 3</span><br><span class="line">窗口: [1, 3] (大小不足k，不记录结果)</span><br><span class="line"></span><br><span class="line">操作:</span><br><span class="line">1. 检查队首索引0是否在窗口内: 0 &lt;= 1-3? 0 &lt;= -2? 否，保留</span><br><span class="line">2. 从队尾开始比较: nums[0]=1 &lt; 3，移除索引0</span><br><span class="line">3. 添加索引1</span><br><span class="line">4. dq = [1] → 对应值 [3]</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">- 3比1大，所以移除1，队列中只保留3</span><br><span class="line">- 当前窗口[1,3]的最大值是3</span><br><span class="line">- 但窗口大小不足k，不记录结果</span><br></pre></td></tr></table></figure></li><li><p>步骤3: i&#x3D;2, nums[2]&#x3D;-1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">当前元素: -1</span><br><span class="line">窗口: [1, 3, -1] (大小达到k，记录结果)</span><br><span class="line"></span><br><span class="line">操作:</span><br><span class="line">1. 检查队首索引1是否在窗口内: 1 &lt;= 2-3? 1 &lt;= -1? 否，保留</span><br><span class="line">2. 从队尾开始比较: nums[1]=3 &gt; -1，不移除，直接添加索引2</span><br><span class="line">3. dq = [1, 2] → 对应值 [3, -1]</span><br><span class="line">4. 记录结果: nums[1] = 3</span><br><span class="line">5. result = [3]</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">- 3比-1大，所以保留3在队首，-1添加到队尾</span><br><span class="line">- 队列保持递减: [3, -1]</span><br><span class="line">- 当前窗口[1,3,-1]的最大值是3，由队首元素提供</span><br></pre></td></tr></table></figure></li><li><p>步骤4: i&#x3D;3, nums[3]&#x3D;-3</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">当前元素: -3</span><br><span class="line">窗口: [3, -1, -3] (大小达到k，记录结果)</span><br><span class="line"></span><br><span class="line">操作:</span><br><span class="line">1. 检查队首索引1是否在窗口内: 1 &lt;= 3-3? 1 &lt;= 0? 否，保留</span><br><span class="line">2. 从队尾开始比较: nums[2]=-1 &gt; -3，不移除，直接添加索引3</span><br><span class="line">3. dq = [1, 2, 3] → 对应值 [3, -1, -3]</span><br><span class="line">4. 记录结果: nums[1] = 3</span><br><span class="line">5. result = [3, 3]</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">- -3比-1小，所以直接添加到队尾</span><br><span class="line">- 队列保持递减: [3, -1, -3]</span><br><span class="line">- 当前窗口[3,-1,-3]的最大值是3，由队首元素提供</span><br></pre></td></tr></table></figure></li><li><p>步骤5: i&#x3D;4, nums[4]&#x3D;5</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">当前元素: 5</span><br><span class="line">窗口: [-1, -3, 5] (大小达到k，记录结果)</span><br><span class="line"></span><br><span class="line">操作:</span><br><span class="line">1. 检查队首索引1是否在窗口内: 1 &lt;= 4-3? 1 &lt;= 1? 是，移除索引1</span><br><span class="line">   - 现在 dq = [2, 3] → 对应值 [-1, -3]</span><br><span class="line">2. 从队尾开始比较: nums[3]=-3 &lt; 5，移除索引3</span><br><span class="line">   - 现在 dq = [2] → 对应值 [-1]</span><br><span class="line">3. 继续比较: nums[2]=-1 &lt; 5，移除索引2</span><br><span class="line">   - 现在 dq = [] (空)</span><br><span class="line">4. 添加索引4</span><br><span class="line">5. dq = [4] → 对应值 [5]</span><br><span class="line">6. 记录结果: nums[4] = 5</span><br><span class="line">7. result = [3, 3, 5]</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">- 首先移除不在窗口内的索引1(对应值3)</span><br><span class="line">- 然后移除所有比5小的元素(-1和-3)</span><br><span class="line">- 队列中只剩下5</span><br><span class="line">- 当前窗口[-1,-3,5]的最大值是5，由队首元素提供</span><br></pre></td></tr></table></figure></li><li><p>步骤6: i&#x3D;5, nums[5]&#x3D;3</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">当前元素: 3</span><br><span class="line">窗口: [-3, 5, 3] (大小达到k，记录结果)</span><br><span class="line"></span><br><span class="line">操作:</span><br><span class="line">1. 检查队首索引4是否在窗口内: 4 &lt;= 5-3? 4 &lt;= 2? 否，保留</span><br><span class="line">2. 从队尾开始比较: nums[4]=5 &gt; 3，不移除，直接添加索引5</span><br><span class="line">3. dq = [4, 5] → 对应值 [5, 3]</span><br><span class="line">4. 记录结果: nums[4] = 5</span><br><span class="line">5. result = [3, 3, 5, 5]</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">- 5比3大，所以保留5在队首，3添加到队尾</span><br><span class="line">- 队列保持递减: [5, 3]</span><br><span class="line">- 当前窗口[-3,5,3]的最大值是5，由队首元素提供</span><br></pre></td></tr></table></figure></li><li><p>步骤7: i&#x3D;6, nums[6]&#x3D;6</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">当前元素: 6</span><br><span class="line">窗口: [5, 3, 6] (大小达到k，记录结果)</span><br><span class="line"></span><br><span class="line">操作:</span><br><span class="line">1. 检查队首索引4是否在窗口内: 4 &lt;= 6-3? 4 &lt;= 3? 否，保留</span><br><span class="line">2. 从队尾开始比较: nums[5]=3 &lt; 6，移除索引5</span><br><span class="line">   - 现在 dq = [4] → 对应值 [5]</span><br><span class="line">3. 继续比较: nums[4]=5 &lt; 6，移除索引4</span><br><span class="line">   - 现在 dq = [] (空)</span><br><span class="line">4. 添加索引6</span><br><span class="line">5. dq = [6] → 对应值 [6]</span><br><span class="line">6. 记录结果: nums[6] = 6</span><br><span class="line">7. result = [3, 3, 5, 5, 6]</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">- 移除所有比6小的元素(5和3)</span><br><span class="line">- 队列中只剩下6</span><br><span class="line">- 当前窗口[5,3,6]的最大值是6，由队首元素提供</span><br></pre></td></tr></table></figure></li><li><p>步骤8: i&#x3D;7, nums[7]&#x3D;7</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">当前元素: 7</span><br><span class="line">窗口: [3, 6, 7] (大小达到k，记录结果)</span><br><span class="line"></span><br><span class="line">操作:</span><br><span class="line">1. 检查队首索引6是否在窗口内: 6 &lt;= 7-3? 6 &lt;= 4? 否，保留</span><br><span class="line">2. 从队尾开始比较: nums[6]=6 &lt; 7，移除索引6</span><br><span class="line">   - 现在 dq = [] (空)</span><br><span class="line">3. 添加索引7</span><br><span class="line">4. dq = [7] → 对应值 [7]</span><br><span class="line">5. 记录结果: nums[7] = 7</span><br><span class="line">6. result = [3, 3, 5, 5, 6, 7]</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">- 移除所有比7小的元素(6)</span><br><span class="line">- 队列中只剩下7</span><br><span class="line">- 当前窗口[3,6,7]的最大值是7，由队首元素提供</span><br></pre></td></tr></table></figure></li></ul><h3 id="为什么队首总是最大值？"><a href="#为什么队首总是最大值？" class="headerlink" title="为什么队首总是最大值？"></a>为什么队首总是最大值？</h3><p>通过这个详细示例，我们可以看到：</p><ul><li>队列始终保持递减：从队首到队尾，元素值逐渐减小</li><li>队首元素总是在窗口内：我们定期检查并移除不在窗口内的元素</li><li>没有更大的元素被遗漏：<br>  如果有更大的元素，它会在加入队列时移除所有比它小的元素<br>  然后它自己成为新的队首<br>因此，在每一步中，队首元素都代表了当前窗口中的最大值。<br>这个算法的巧妙之处在于，它通过维护一个单调递减队列，使得我们可以在O(1)时间内获取当前窗口的最大值，而维护队列的均摊时间复杂度也是O(1)，整体算法时间复杂度为O(n)。</li></ul><h3 id="python版"><a href="#python版" class="headerlink" title="python版"></a>python版</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">from collections import deque</span><br><span class="line"></span><br><span class="line">def maxSlidingWindow(nums, k):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    使用双端队列找到滑动窗口的最大值</span><br><span class="line">    </span><br><span class="line">    参数:</span><br><span class="line">        nums: 整数数组</span><br><span class="line">        k: 滑动窗口的大小</span><br><span class="line">    </span><br><span class="line">    返回:</span><br><span class="line">        一个列表，包含每个滑动窗口的最大值</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 存储结果的最大值</span><br><span class="line">    result = []</span><br><span class="line">    # 使用双端队列，存储数组元素的索引</span><br><span class="line">    # 队列中的索引对应的元素值是递减的（队首元素最大）</span><br><span class="line">    dq = deque()</span><br><span class="line">    </span><br><span class="line">    # 遍历数组中的每个元素</span><br><span class="line">    for i in range(len(nums)):</span><br><span class="line">        # 移除队列中已经不在当前窗口的索引</span><br><span class="line">        # 如果队首索引小于等于i-k，说明它不在当前窗口内，需要移除</span><br><span class="line">        if dq and dq[0] &lt;= i - k:</span><br><span class="line">            dq.popleft()  # 从队首移除</span><br><span class="line">        </span><br><span class="line">        # 从队尾开始，移除所有小于当前元素的索引</span><br><span class="line">        # 因为这些元素不可能成为当前或未来窗口的最大值</span><br><span class="line">        while dq and nums[dq[-1]] &lt; nums[i]:</span><br><span class="line">            dq.pop()  # 从队尾移除</span><br><span class="line">        </span><br><span class="line">        # 将当前元素的索引加入队尾</span><br><span class="line">        dq.append(i)</span><br><span class="line">        </span><br><span class="line">        # 当窗口大小达到k时，开始记录结果</span><br><span class="line">        # i从0开始，所以当i &gt;= k-1时，窗口大小达到k</span><br><span class="line">        if i &gt;= k - 1:</span><br><span class="line">            # 队首元素就是当前窗口的最大值</span><br><span class="line">            result.append(nums[dq[0]])</span><br><span class="line">    </span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line"># 测试代码</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    # 示例1</span><br><span class="line">    nums1 = [1, 3, -1, -3, 5, 3, 6, 7]</span><br><span class="line">    k1 = 3</span><br><span class="line">    print(f&quot;输入: nums = &#123;nums1&#125;, k = &#123;k1&#125;&quot;)</span><br><span class="line">    print(f&quot;输出: &#123;maxSlidingWindow(nums1, k1)&#125;&quot;)  # 输出: [3, 3, 5, 5, 6, 7]</span><br><span class="line">    </span><br><span class="line">    # 示例2</span><br><span class="line">    nums2 = [1]</span><br><span class="line">    k2 = 1</span><br><span class="line">    print(f&quot;输入: nums = &#123;nums2&#125;, k = &#123;k2&#125;&quot;)</span><br><span class="line">    print(f&quot;输出: &#123;maxSlidingWindow(nums2, k2)&#125;&quot;)  # 输出: [1]</span><br><span class="line">    </span><br><span class="line">    # 额外测试用例</span><br><span class="line">    nums3 = [7, 2, 4]</span><br><span class="line">    k3 = 2</span><br><span class="line">    print(f&quot;输入: nums = &#123;nums3&#125;, k = &#123;k3&#125;&quot;)</span><br><span class="line">    print(f&quot;输出: &#123;maxSlidingWindow(nums3, k3)&#125;&quot;)  # 输出: [7, 4]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>法算day10</title>
      <link href="/lief/%E6%B3%95%E7%AE%97day10/"/>
      <url>/lief/%E6%B3%95%E7%AE%97day10/</url>
      
        <content type="html"><![CDATA[<div class="video-container">[up主专用，视频内嵌代码贴在这]</div><style>.video-container {    position: relative;    width: 100%;    padding-top: 56.25%; /* 16:9 aspect ratio (height/width = 9/16 * 100%) */}.video-container iframe {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;}</style><h1 id="和为k的子数组"><a href="#和为k的子数组" class="headerlink" title="和为k的子数组"></a>和为k的子数组</h1><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。<br>子数组是数组中元素的<strong>连续非空序列</strong>。</p><ul><li><p>示例 1：<br>输入：nums &#x3D; [1,1,1], k &#x3D; 2<br>输出：2</p></li><li><p>示例 2：<br>输入：nums &#x3D; [1,2,3], k &#x3D; 3<br>输出：2</p></li></ul><p>提示：<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 2 * 104<br>-1000 &lt;&#x3D; nums[i] &lt;&#x3D; 1000<br>-107 &lt;&#x3D; k &lt;&#x3D; 107</p><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>这个问题的关键在于理解前缀和的概念：</p><ol><li>前缀和是指从数组起始位置到当前位置的所有元素之和</li><li>如果从位置 i 到位置 j 的子数组和为 k，那么 <code>prefix_sum[j] - prefix_sum[i-1] = k</code></li><li>可以转化为 <code>prefix_sum[j] - k = prefix_sum[i-1]</code></li></ol><h3 id="python版（前缀和-哈希表）"><a href="#python版（前缀和-哈希表）" class="headerlink" title="python版（前缀和+哈希表）"></a>python版（前缀和+哈希表）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">def subarraySum(nums, k):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    统计数组中所有和为k的连续子数组的个数</span><br><span class="line">    </span><br><span class="line">    参数:</span><br><span class="line">        nums: 整数数组</span><br><span class="line">        k: 目标和</span><br><span class="line">    </span><br><span class="line">    返回:</span><br><span class="line">        count: 和为k的连续子数组的个数</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 初始化前缀和字典，记录每个前缀和出现的次数</span><br><span class="line">    # 初始时前缀和为0出现1次，表示空数组的情况</span><br><span class="line">    prefix_sum_count = &#123;0: 1&#125;</span><br><span class="line">    </span><br><span class="line">    # 初始化当前前缀和</span><br><span class="line">    current_sum = 0</span><br><span class="line">    </span><br><span class="line">    # 初始化计数器</span><br><span class="line">    count = 0</span><br><span class="line">    </span><br><span class="line">    # 遍历数组中的每个元素</span><br><span class="line">    for num in nums:</span><br><span class="line">        # 更新当前前缀和</span><br><span class="line">        current_sum += num</span><br><span class="line">        </span><br><span class="line">        # 检查是否存在一个前缀和，使得 current_sum - 该前缀和 = k</span><br><span class="line">        # 如果存在，说明从该前缀和位置到当前位置的子数组和为k</span><br><span class="line">        if current_sum - k in prefix_sum_count:</span><br><span class="line">            count += prefix_sum_count[current_sum - k]</span><br><span class="line">        </span><br><span class="line">        # 更新当前前缀和的出现次数</span><br><span class="line">        if current_sum in prefix_sum_count: # 如果当前前缀和已经在字典中，</span><br><span class="line">            prefix_sum_count[current_sum] += 1 # 则次数加1</span><br><span class="line">        else:</span><br><span class="line">            prefix_sum_count[current_sum] = 1 # 如果不存在，则初始化为1</span><br><span class="line">    </span><br><span class="line">    return count</span><br><span class="line"></span><br><span class="line"># 测试代码</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    # 示例1</span><br><span class="line">    nums1 = [1, 1, 1]</span><br><span class="line">    k1 = 2</span><br><span class="line">    print(f&quot;输入: nums = &#123;nums1&#125;, k = &#123;k1&#125;&quot;)</span><br><span class="line">    print(f&quot;输出: &#123;subarraySum(nums1, k1)&#125;&quot;)  # 输出: 2</span><br><span class="line">    </span><br><span class="line">    # 示例2</span><br><span class="line">    nums2 = [1, 2, 3]</span><br><span class="line">    k2 = 3</span><br><span class="line">    print(f&quot;输入: nums = &#123;nums2&#125;, k = &#123;k2&#125;&quot;)</span><br><span class="line">    print(f&quot;输出: &#123;subarraySum(nums2, k2)&#125;&quot;)  # 输出: 2</span><br><span class="line">    </span><br><span class="line">    # 额外测试用例</span><br><span class="line">    nums3 = [1, 3, 2,4,5,6]</span><br><span class="line">    k3 = 6</span><br><span class="line">    print(f&quot;输入: nums = &#123;nums3&#125;, k = &#123;k3&#125;&quot;)</span><br><span class="line">    print(f&quot;输出: &#123;subarraySum(nums3, k3)&#125;&quot;)  # 输出: 3</span><br></pre></td></tr></table></figure><p>✅ 说明：</p><ul><li>时间复杂度: O(n)，只需要遍历数组一次</li><li>空间复杂度: O(n)，最坏情况下需要存储n个不同的前缀和</li></ul><h3 id="疑点：为什么需要初始化-0-1"><a href="#疑点：为什么需要初始化-0-1" class="headerlink" title="疑点：为什么需要初始化 {0: 1}"></a>疑点：为什么需要初始化 {0: 1}</h3><p>初始化 prefix_sum_count &#x3D; {0: 1} 是为了处理从数组开头开始的子数组：</p><ul><li>当子数组从索引0开始时，prefix_sum[i-1] 实际上不存在</li><li>我们可以将其视为前缀和为0，出现在索引-1位置</li><li>这样就能统一处理所有情况</li></ul><h3 id="示例说明：nums3-1-3-2-4-5-6-k3-6"><a href="#示例说明：nums3-1-3-2-4-5-6-k3-6" class="headerlink" title="示例说明：nums3 &#x3D; [1, 3, 2, 4, 5, 6], k3 &#x3D; 6"></a>示例说明：nums3 &#x3D; [1, 3, 2, 4, 5, 6], k3 &#x3D; 6</h3><ul><li>初始状态<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nums = [1, 3, 2, 4, 5, 6]</span><br><span class="line">k = 6</span><br><span class="line">prefix_sum_count = &#123;0: 1&#125;  # 初始前缀和字典，0出现1次</span><br><span class="line">current_sum = 0</span><br><span class="line">count = 0</span><br></pre></td></tr></table></figure></li><li>第1次循环 (i&#x3D;0, num&#x3D;1)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">当前元素: nums[0] = 1</span><br><span class="line">更新当前前缀和: current_sum = 0 + 1 = 1</span><br><span class="line"></span><br><span class="line">检查是否存在 current_sum - k = 1 - 6 = -5 在 prefix_sum_count 中</span><br><span class="line">- -5 不在字典中，所以 count 不变 (count=0)</span><br><span class="line"></span><br><span class="line">更新前缀和字典: prefix_sum_count[1] = 1</span><br><span class="line">现在 prefix_sum_count = &#123;0: 1, 1: 1&#125;</span><br></pre></td></tr></table></figure></li><li>第2次循环 (i&#x3D;1, num&#x3D;3)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">当前元素: nums[1] = 3</span><br><span class="line">更新当前前缀和: current_sum = 1 + 3 = 4</span><br><span class="line"></span><br><span class="line">检查是否存在 current_sum - k = 4 - 6 = -2 在 prefix_sum_count 中</span><br><span class="line">- -2 不在字典中，所以 count 不变 (count=0)</span><br><span class="line"></span><br><span class="line">更新前缀和字典: prefix_sum_count[4] = 1</span><br><span class="line">现在 prefix_sum_count = &#123;0: 1, 1: 1, 4: 1&#125;</span><br></pre></td></tr></table></figure>-第3次循环 (i&#x3D;2, num&#x3D;2)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">当前元素: nums[2] = 2</span><br><span class="line">更新当前前缀和: current_sum = 4 + 2 = 6</span><br><span class="line"></span><br><span class="line">检查是否存在 current_sum - k = 6 - 6 = 0 在 prefix_sum_count 中</span><br><span class="line">- 0 在字典中，出现次数为1</span><br><span class="line">- 所以 count += 1 → count = 1</span><br><span class="line"></span><br><span class="line">更新前缀和字典: prefix_sum_count[6] = 1</span><br><span class="line">现在 prefix_sum_count = &#123;0: 1, 1: 1, 4: 1, 6: 1&#125;</span><br></pre></td></tr></table></figure></li><li>第4次循环 (i&#x3D;3, num&#x3D;4)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">当前元素: nums[3] = 4</span><br><span class="line">更新当前前缀和: current_sum = 6 + 4 = 10</span><br><span class="line"></span><br><span class="line">检查是否存在 current_sum - k = 10 - 6 = 4 在 prefix_sum_count 中</span><br><span class="line">- 4 在字典中，出现次数为1</span><br><span class="line">- 所以 count += 1 → count = 2</span><br><span class="line"></span><br><span class="line">更新前缀和字典: prefix_sum_count[10] = 1</span><br><span class="line">现在 prefix_sum_count = &#123;0: 1, 1: 1, 4: 1, 6: 1, 10: 1&#125;</span><br></pre></td></tr></table></figure></li><li>第5次循环 (i&#x3D;4, num&#x3D;5)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">当前元素: nums[4] = 5</span><br><span class="line">更新当前前缀和: current_sum = 10 + 5 = 15</span><br><span class="line"></span><br><span class="line">检查是否存在 current_sum - k = 15 - 6 = 9 在 prefix_sum_count 中</span><br><span class="line">- 9 不在字典中，所以 count 不变 (count=2)</span><br><span class="line"></span><br><span class="line">更新前缀和字典: prefix_sum_count[15] = 1</span><br><span class="line">现在 prefix_sum_count = &#123;0: 1, 1: 1, 4: 1, 6: 1, 10: 1, 15: 1&#125;</span><br></pre></td></tr></table></figure></li><li>第6次循环 (i&#x3D;5, num&#x3D;6)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">当前元素: nums[5] = 6</span><br><span class="line">更新当前前缀和: current_sum = 15 + 6 = 21</span><br><span class="line"></span><br><span class="line">检查是否存在 current_sum - k = 21 - 6 = 15 在 prefix_sum_count 中</span><br><span class="line">- 15 在字典中，出现次数为1</span><br><span class="line">- 所以 count += 1 → count = 3</span><br><span class="line"></span><br><span class="line">更新前缀和字典: prefix_sum_count[21] = 1</span><br><span class="line">现在 prefix_sum_count = &#123;0: 1, 1: 1, 4: 1, 6: 1, 10: 1, 15: 1, 21: 1&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="java版"><a href="#java版" class="headerlink" title="java版"></a>java版</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class SubarraySum &#123;</span><br><span class="line">    public int subarraySum(int[] nums, int k) &#123;</span><br><span class="line">        // 使用哈希表存储前缀和及其出现的次数</span><br><span class="line">        // key: 前缀和, value: 该前缀和出现的次数</span><br><span class="line">        Map&lt;Integer, Integer&gt; prefixSumCount = new HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        // 初始化：前缀和为0出现了1次（即不选择任何元素的情况）</span><br><span class="line">        prefixSumCount.put(0, 1);</span><br><span class="line">        </span><br><span class="line">        int count = 0; // 记录满足条件的子数组个数</span><br><span class="line">        int prefixSum = 0; // 当前前缀和</span><br><span class="line">        </span><br><span class="line">        // 遍历数组中的每个元素</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            // 计算当前的前缀和</span><br><span class="line">            prefixSum += num;</span><br><span class="line">            </span><br><span class="line">            // 如果存在前缀和等于 (当前前缀和 - k)，说明找到了和为k的子数组</span><br><span class="line">            // 因为：prefixSum - (prefixSum - k) = k</span><br><span class="line">            if (prefixSumCount.containsKey(prefixSum - k)) &#123;</span><br><span class="line">                // 累加满足条件的子数组个数</span><br><span class="line">                count += prefixSumCount.get(prefixSum - k);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 更新当前前缀和的出现次数</span><br><span class="line">            // 如果当前前缀和已经存在，次数+1；否则初始化为1</span><br><span class="line">            prefixSumCount.put(prefixSum, prefixSumCount.getOrDefault(prefixSum, 0) + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 测试代码</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SubarraySum solution = new SubarraySum();</span><br><span class="line">        </span><br><span class="line">        // 示例1</span><br><span class="line">        int[] nums1 = &#123;1, 1, 1&#125;;</span><br><span class="line">        int k1 = 2;</span><br><span class="line">        System.out.println(&quot;输入: nums = [1,1,1], k = 2&quot;);</span><br><span class="line">        System.out.println(&quot;输出: &quot; + solution.subarraySum(nums1, k1)); // 输出: 2</span><br><span class="line">        </span><br><span class="line">        // 示例2</span><br><span class="line">        int[] nums2 = &#123;1, 2, 3&#125;;</span><br><span class="line">        int k2 = 3;</span><br><span class="line">        System.out.println(&quot;输入: nums = [1,2,3], k = 3&quot;);</span><br><span class="line">        System.out.println(&quot;输出: &quot; + solution.subarraySum(nums2, k2)); // 输出: 2</span><br><span class="line">        </span><br><span class="line">        // 额外测试用例</span><br><span class="line">        int[] nums3 = &#123;1, -1, 0&#125;;</span><br><span class="line">        int k3 = 0;</span><br><span class="line">        System.out.println(&quot;输入: nums = [1,-1,0], k = 0&quot;);</span><br><span class="line">        System.out.println(&quot;输出: &quot; + solution.subarraySum(nums3, k3)); // 输出: 3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>法算day9</title>
      <link href="/lief/%E6%B3%95%E7%AE%97day9/"/>
      <url>/lief/%E6%B3%95%E7%AE%97day9/</url>
      
        <content type="html"><![CDATA[<div class="video-container">[up主专用，视频内嵌代码贴在这]</div><style>.video-container {    position: relative;    width: 100%;    padding-top: 56.25%; /* 16:9 aspect ratio (height/width = 9/16 * 100%) */}.video-container iframe {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;}</style><h1 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a>找到字符串中所有字母异位词</h1><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p><p><strong>示例 1:</strong><br>输入: s &#x3D; “cbaebabacd”, p &#x3D; “abc”<br>输出: [0,6]<br>解释:<br>起始索引等于 0 的子串是 “cba”, 它是 “abc” 的异位词。<br>起始索引等于 6 的子串是 “bac”, 它是 “abc” 的异位词。</p><p><strong>示例 2:</strong><br>输入: s &#x3D; “abab”, p &#x3D; “ab”<br>输出: [0,1,2]<br>解释:<br>起始索引等于 0 的子串是 “ab”, 它是 “ab” 的异位词。<br>起始索引等于 1 的子串是 “ba”, 它是 “ab” 的异位词。<br>起始索引等于 2 的子串是 “ab”, 它是 “ab” 的异位词。</p><p>提示:<br>1 &lt;&#x3D; s.length, p.length &lt;&#x3D; 3 * 104<br>s 和 p 仅包含小写字母</p><h3 id="java版（滑动窗口-字符频率）"><a href="#java版（滑动窗口-字符频率）" class="headerlink" title="java版（滑动窗口+字符频率）"></a>java版（滑动窗口+字符频率）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class FindAnagrams &#123;</span><br><span class="line">    public List&lt;Integer&gt; findAnagrams(String s, String p) &#123;</span><br><span class="line">        // 创建结果列表，用于存储所有异位词的起始索引</span><br><span class="line">        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        // 如果s的长度小于p的长度，直接返回空结果</span><br><span class="line">        if (s == null || p == null || s.length() &lt; p.length()) &#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 创建两个数组来记录字符出现的频率</span><br><span class="line">        // 因为字符串只包含小写字母，所以使用长度为26的数组</span><br><span class="line">        int[] pCount = new int[26];  // 记录p中每个字符的出现次数</span><br><span class="line">        int[] sCount = new int[26];  // 记录当前窗口中每个字符的出现次数</span><br><span class="line">        </span><br><span class="line">        // 初始化p的字符频率数组</span><br><span class="line">        for (int i = 0; i &lt; p.length(); i++) &#123;</span><br><span class="line">            pCount[p.charAt(i) - &#x27;a&#x27;]++;  // 将字符映射到0-25的索引，并增加计数</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 初始化滑动窗口</span><br><span class="line">        // 窗口大小等于p的长度，从s的开头开始</span><br><span class="line">        for (int i = 0; i &lt; p.length(); i++) &#123;</span><br><span class="line">            sCount[s.charAt(i) - &#x27;a&#x27;]++;  // 记录s中前p.length()个字符的频率</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 检查第一个窗口是否是p的异位词</span><br><span class="line">        if (isAnagram(pCount, sCount)) &#123;</span><br><span class="line">            result.add(0);  // 如果是，添加起始索引0</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 滑动窗口：每次向右移动一位</span><br><span class="line">        for (int i = p.length(); i &lt; s.length(); i++) &#123;//当前i代表右边界索引</span><br><span class="line">            // 移除窗口最左边的字符</span><br><span class="line">            char leftChar = s.charAt(i - p.length());//计算左边界字符位置：i - p.length()</span><br><span class="line">                                                     //获取左边界字符：s.charAt(i - p.length())</span><br><span class="line">            sCount[leftChar - &#x27;a&#x27;]--;//减少该字符的计数,因为该字符即将离开窗口</span><br><span class="line">            </span><br><span class="line">            // 添加窗口最右边的字符（新字符）</span><br><span class="line">            char rightChar = s.charAt(i);//获取右边界字符</span><br><span class="line">            sCount[rightChar - &#x27;a&#x27;]++;//增加该字符的计数</span><br><span class="line">            </span><br><span class="line">            // 检查当前窗口是否是p的异位词</span><br><span class="line">            if (isAnagram(pCount, sCount)) &#123;</span><br><span class="line">                // 如果是，添加起始索引（当前索引减去p的长度加1）</span><br><span class="line">                result.add(i - p.length() + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 辅助方法：检查两个字符频率数组是否相同</span><br><span class="line">    private boolean isAnagram(int[] pCount, int[] sCount) &#123;</span><br><span class="line">        // 遍历26个字母，比较每个字母的出现次数</span><br><span class="line">        for (int i = 0; i &lt; 26; i++) &#123;</span><br><span class="line">            if (pCount[i] != sCount[i]) &#123;</span><br><span class="line">                return false;  // 如果有任何一个字母出现次数不同，返回false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;  // 所有字母出现次数都相同，返回true</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 测试代码</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        FindAnagrams solution = new FindAnagrams();</span><br><span class="line">        </span><br><span class="line">        // 示例1</span><br><span class="line">        String s1 = &quot;cbaebabacd&quot;;</span><br><span class="line">        String p1 = &quot;abc&quot;;</span><br><span class="line">        System.out.println(&quot;输入: s = \&quot;&quot; + s1 + &quot;\&quot;, p = \&quot;&quot; + p1 + &quot;\&quot;&quot;);</span><br><span class="line">        System.out.println(&quot;输出: &quot; + solution.findAnagrams(s1, p1)); // 输出: [0,6]</span><br><span class="line">        </span><br><span class="line">        // 示例2</span><br><span class="line">        String s2 = &quot;abab&quot;;</span><br><span class="line">        String p2 = &quot;ab&quot;;</span><br><span class="line">        System.out.println(&quot;输入: s = \&quot;&quot; + s2 + &quot;\&quot;, p = \&quot;&quot; + p2 + &quot;\&quot;&quot;);</span><br><span class="line">        System.out.println(&quot;输出: &quot; + solution.findAnagrams(s2, p2)); // 输出: [0,1,2]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ 说明：</p><ol><li>时间复杂度：O(n)，其中n是s的长度</li><li>空间复杂度：O(1)，因为使用了固定大小的数组</li></ol><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p><strong>初试状态</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pCount: [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]</span><br><span class="line">         a b c d e f g h i j k l m n o p q r s t u v w x y z</span><br><span class="line">         </span><br><span class="line">sCount: [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]</span><br><span class="line">         a b c d e f g h i j k l m n o p q r s t u v w x y z</span><br><span class="line"></span><br><span class="line">第一个窗口: &quot;cba&quot; → 匹配，添加索引0</span><br></pre></td></tr></table></figure><p><strong>窗口1: i&#x3D;3 (索引0-2)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">移除: s[0] = &#x27;c&#x27; → sCount[2]从1变为0</span><br><span class="line">添加: s[3] = &#x27;e&#x27; → sCount[4]从0变为1</span><br><span class="line"></span><br><span class="line">当前窗口: &quot;bae&quot; (索引1-3)</span><br><span class="line">sCount: [1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]</span><br><span class="line">         a b c d e f g h i j k l m n o p q r s t u v w x y z</span><br><span class="line">         </span><br><span class="line">比较pCount和sCount: 不匹配</span><br></pre></td></tr></table></figure><p><strong>窗口2: i&#x3D;4 (索引1-3)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">移除: s[1] = &#x27;b&#x27; → sCount[1]从1变为0</span><br><span class="line">添加: s[4] = &#x27;b&#x27; → sCount[1]从0变为1</span><br><span class="line"></span><br><span class="line">当前窗口: &quot;aeb&quot; (索引2-4)</span><br><span class="line">sCount: [1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]</span><br><span class="line">         a b c d e f g h i j k l m n o p q r s t u v w x y z</span><br><span class="line">         </span><br><span class="line">比较pCount和sCount: 不匹配</span><br></pre></td></tr></table></figure><p><strong>窗口3: i&#x3D;5 (索引2-4)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">移除: s[2] = &#x27;a&#x27; → sCount[0]从1变为0</span><br><span class="line">添加: s[5] = &#x27;a&#x27; → sCount[0]从0变为1</span><br><span class="line"></span><br><span class="line">当前窗口: &quot;eba&quot; (索引3-5)</span><br><span class="line">sCount: [1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]</span><br><span class="line">         a b c d e f g h i j k l m n o p q r s t u v w x y z</span><br><span class="line">         </span><br><span class="line">比较pCount和sCount: 不匹配</span><br></pre></td></tr></table></figure><p><strong>窗口4: i&#x3D;6 (索引3-5)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">移除: s[3] = &#x27;e&#x27; → sCount[4]从1变为0</span><br><span class="line">添加: s[6] = &#x27;b&#x27; → sCount[1]从1变为2</span><br><span class="line"></span><br><span class="line">当前窗口: &quot;bab&quot; (索引4-6)</span><br><span class="line">sCount: [1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]</span><br><span class="line">         a b c d e f g h i j k l m n o p q r s t u v w x y z</span><br><span class="line">         </span><br><span class="line">比较pCount和sCount: 不匹配 (b的计数不同)</span><br></pre></td></tr></table></figure><p><strong>窗口5: i&#x3D;7 (索引4-6)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">移除: s[4] = &#x27;b&#x27; → sCount[1]从2变为1</span><br><span class="line">添加: s[7] = &#x27;a&#x27; → sCount[0]从1变为2</span><br><span class="line"></span><br><span class="line">当前窗口: &quot;aba&quot; (索引5-7)</span><br><span class="line">sCount: [2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]</span><br><span class="line">         a b c d e f g h i j k l m n o p q r s t u v w x y z</span><br><span class="line">         </span><br><span class="line">比较pCount和sCount: 不匹配 (a的计数不同)</span><br></pre></td></tr></table></figure><p><strong>窗口6: i&#x3D;8 (索引5-7)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">移除: s[5] = &#x27;a&#x27; → sCount[0]从2变为1</span><br><span class="line">添加: s[8] = &#x27;c&#x27; → sCount[2]从0变为1</span><br><span class="line"></span><br><span class="line">当前窗口: &quot;bac&quot; (索引6-8)</span><br><span class="line">sCount: [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]</span><br><span class="line">         a b c d e f g h i j k l m n o p q r s t u v w x y z</span><br><span class="line">         </span><br><span class="line">比较pCount和sCount: 匹配，添加索引6</span><br></pre></td></tr></table></figure><p><strong>窗口7: i&#x3D;9 (索引6-8)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">移除: s[6] = &#x27;b&#x27; → sCount[1]从1变为0</span><br><span class="line">添加: s[9] = &#x27;d&#x27; → sCount[3]从0变为1</span><br><span class="line"></span><br><span class="line">当前窗口: &quot;acd&quot; (索引7-9)</span><br><span class="line">sCount: [1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]</span><br><span class="line">         a b c d e f g h i j k l m n o p q r s t u v w x y z</span><br><span class="line">         </span><br><span class="line">比较pCount和sCount: 不匹配</span><br></pre></td></tr></table></figure><h3 id="python版"><a href="#python版" class="headerlink" title="python版"></a>python版</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">from collections import defaultdict  # 导入defaultdict，它是字典的一个子类，提供默认值功能</span><br><span class="line"></span><br><span class="line">def findAnagrams_optimized(s, p):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    优化版本：使用固定大小的滑动窗口</span><br><span class="line">    参数:</span><br><span class="line">        s: 主字符串，我们要在其中搜索</span><br><span class="line">        p: 目标字符串，我们要找它的异位词</span><br><span class="line">    返回:</span><br><span class="line">        result: 包含所有异位词起始索引的列表</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    result = []  # 初始化结果列表，用于存储找到的异位词起始索引</span><br><span class="line">    </span><br><span class="line">    # 边界情况检查：如果p比s长，不可能找到异位词，直接返回空列表</span><br><span class="line">    if len(p) &gt; len(s):</span><br><span class="line">        return result</span><br><span class="line">    </span><br><span class="line">    # 使用defaultdict(int)创建两个计数器</span><br><span class="line">    # defaultdict(int)会自动为不存在的键提供默认值0，避免KeyError</span><br><span class="line">    p_count = defaultdict(int)  # 用于统计目标字符串p中每个字符的出现次数</span><br><span class="line">    window_count = defaultdict(int)  # 用于统计当前滑动窗口中每个字符的出现次数</span><br><span class="line">    </span><br><span class="line">    # 初始化p的字符计数：遍历p中的每个字符，在p_count中增加对应计数</span><br><span class="line">    for char in p:</span><br><span class="line">        p_count[char] += 1  # 记录p中每个字符的出现次数</span><br><span class="line">    </span><br><span class="line">    # 初始化窗口：在s的前len(p)个字符上初始化第一个窗口</span><br><span class="line">    for i in range(len(p)):</span><br><span class="line">        window_count[s[i]] += 1  # 统计第一个窗口中每个字符的出现次数</span><br><span class="line">    </span><br><span class="line">    # 检查第一个窗口：如果第一个窗口的字符计数与p的字符计数相同，则记录起始索引0</span><br><span class="line">    if window_count == p_count:</span><br><span class="line">        result.append(0)  # 第一个窗口就是异位词，记录索引0</span><br><span class="line">    </span><br><span class="line">    # 滑动窗口：从索引len(p)开始，到s的末尾</span><br><span class="line">    for i in range(len(p), len(s)):</span><br><span class="line">        # 添加新字符：将当前右指针指向的字符加入窗口计数器</span><br><span class="line">        window_count[s[i]] += 1</span><br><span class="line">        </span><br><span class="line">        # 移除旧字符：将窗口最左边的字符（即当前索引减去p长度位置的字符）从窗口计数器中移除</span><br><span class="line">        window_count[s[i - len(p)]] -= 1</span><br><span class="line">        </span><br><span class="line">        # 如果某个字符计数减为0，则从字典中删除该键</span><br><span class="line">        # 这是为了确保窗口计数器和p计数器的比较是准确的</span><br><span class="line">        if window_count[s[i - len(p)]] == 0:</span><br><span class="line">            del window_count[s[i - len(p)]]  # 删除计数为0的字符，避免干扰比较</span><br><span class="line">        </span><br><span class="line">        # 检查当前窗口：如果窗口内字符计数与p的字符计数相同，则找到异位词</span><br><span class="line">        if window_count == p_count:</span><br><span class="line">            # 计算当前窗口的起始索引：当前索引i减去p长度再加1</span><br><span class="line">            result.append(i - len(p) + 1)</span><br><span class="line">    </span><br><span class="line">    return result  # 返回所有找到的异位词起始索引</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>法算day8</title>
      <link href="/lief/%E6%B3%95%E7%AE%97day8/"/>
      <url>/lief/%E6%B3%95%E7%AE%97day8/</url>
      
        <content type="html"><![CDATA[<div class="video-container">[up主专用，视频内嵌代码贴在这]</div><style>.video-container {    position: relative;    width: 100%;    padding-top: 56.25%; /* 16:9 aspect ratio (height/width = 9/16 * 100%) */}.video-container iframe {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;}</style><h1 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h1><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个字符串 s ，请你找出其中<strong>不含有重复字符的最长子串的长度</strong>。</p><p><strong>示例 1:</strong><br>输入: s &#x3D; “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。注意 “bca” 和 “cab” 也是正确答案。</p><p><strong>示例 2:</strong><br>输入: s &#x3D; “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p><p><strong>示例 3:</strong><br>输入: s &#x3D; “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p><p>提示：<br>0 &lt;&#x3D; s.length &lt;&#x3D; 5 * 104<br>s 由英文字母、数字、符号和空格组成</p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>这个问题使用<strong>滑动窗口（双指针）</strong>的方法来解决。我们维护一个窗口，窗口内的字符都是不重复的。通过左右两个指针来定义窗口的边界：<br>右指针不断向右移动，扩展窗口<br><strong>当遇到重复字符时，左指针向右移动，缩小窗口</strong><br>在每次扩展窗口后，记录当前窗口的长度，并更新最大长度<br>这种方法的时间复杂度是O(n)，其中n是字符串的长度，因为每个字符最多被访问两次（一次由右指针，一次由左指针）。空间复杂度是O(min(m, n))，其中m是字符集的大小。</p><h3 id="可视化说明-以“abcabcbb”为例"><a href="#可视化说明-以“abcabcbb”为例" class="headerlink" title="可视化说明(以“abcabcbb”为例)"></a>可视化说明(以“abcabcbb”为例)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">初始: [a]bcabcbb         窗口: &quot;a&quot;      长度:1</span><br><span class="line">扩展: [ab]cabcbb         窗口: &quot;ab&quot;     长度:2  </span><br><span class="line">扩展: [abc]abcbb         窗口: &quot;abc&quot;    长度:3</span><br><span class="line">遇到重复: a[bca]bcbb     窗口: &quot;bca&quot;    长度:3</span><br><span class="line">遇到重复: ab[cab]cbb     窗口: &quot;cab&quot;    长度:3</span><br><span class="line">遇到重复: abc[abc]bb     窗口: &quot;abc&quot;    长度:3</span><br><span class="line">遇到重复: abca[bc]bb     窗口: &quot;bc&quot;     长度:2</span><br><span class="line">遇到重复: abcab[cb]b     窗口: &quot;cb&quot;     长度:2</span><br><span class="line">遇到重复: abcabc[b]b     窗口: &quot;b&quot;      长度:1</span><br><span class="line">遇到重复: abcabcb[b]     窗口: &quot;b&quot;      长度:1</span><br></pre></td></tr></table></figure><h3 id="python版"><a href="#python版" class="headerlink" title="python版"></a>python版</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">def lengthOfLongestSubstring(s):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    找出不包含重复字符的最长子串的长度</span><br><span class="line">    使用滑动窗口方法</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 创建一个集合来存储窗口中的字符，用于快速判断字符是否重复</span><br><span class="line">    char_set = set()</span><br><span class="line">    # 左指针，表示当前窗口的起始位置</span><br><span class="line">    left = 0</span><br><span class="line">    # 记录最长子串的长度</span><br><span class="line">    max_length = 0</span><br><span class="line">    </span><br><span class="line">    # 右指针遍历整个字符串</span><br><span class="line">    for right in range(len(s)):</span><br><span class="line">        # 如果当前字符已经在窗口中存在</span><br><span class="line">        while s[right] in char_set:</span><br><span class="line">            # 从窗口中移除左指针指向的字符</span><br><span class="line">            char_set.remove(s[left])</span><br><span class="line">            # 左指针向右移动，缩小窗口</span><br><span class="line">            left += 1</span><br><span class="line">        </span><br><span class="line">        # 将当前字符添加到窗口中</span><br><span class="line">        char_set.add(s[right])</span><br><span class="line">        # 更新最大长度：当前窗口的长度是 right - left + 1</span><br><span class="line">        max_length = max(max_length, right - left + 1)</span><br><span class="line">    </span><br><span class="line">    return max_length</span><br><span class="line"></span><br><span class="line"># 测试代码</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    # 示例1</span><br><span class="line">    s1 = &quot;abcabcbb&quot;</span><br><span class="line">    print(lengthOfLongestSubstring(s1))  # 输出: 3</span><br><span class="line">    </span><br><span class="line">    # 示例2</span><br><span class="line">    s2 = &quot;bbbbb&quot;</span><br><span class="line">    print(lengthOfLongestSubstring(s2))  # 输出: 1</span><br><span class="line">    </span><br><span class="line">    # 示例3</span><br><span class="line">    s3 = &quot;pwwkew&quot;</span><br><span class="line">    print(lengthOfLongestSubstring(s3))  # 输出: 3</span><br></pre></td></tr></table></figure><p>✅ 说明：</p><ol><li>时间复杂度：O(n)，其中n是字符串的长度</li><li>空间复杂度：O(min(m, n))，其中m是字符集的大小</li></ol><h3 id="java版"><a href="#java版" class="headerlink" title="java版"></a>java版</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class LongestSubstringWithoutRepeating &#123;</span><br><span class="line">    public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        // 如果字符串为空或长度为0，直接返回0</span><br><span class="line">        if (s == null || s.length() == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 使用HashMap来存储字符和它们最近出现的位置</span><br><span class="line">        Map&lt;Character, Integer&gt; charIndexMap = new HashMap&lt;&gt;(); //new HashMap&lt;&gt;(): 创建HashMap类的实例</span><br><span class="line">        //Map&lt;Character, Integer&gt;: 声明一个映射接口，键是Character类型，值是Integer类型;charIndexMap: 变量名</span><br><span class="line">        // 初始化最大长度为0</span><br><span class="line">        int maxLength = 0;</span><br><span class="line">        // 初始化滑动窗口的左边界</span><br><span class="line">        int left = 0;</span><br><span class="line">        </span><br><span class="line">        // 遍历字符串，右指针从0到字符串末尾</span><br><span class="line">        for (int right = 0; right &lt; s.length(); right++) &#123;</span><br><span class="line">            char currentChar = s.charAt(right); //字符串类的方法，用于获取指定位置的字符</span><br><span class="line">            </span><br><span class="line">            // 如果当前字符已经在窗口中出现过</span><br><span class="line">            if (charIndexMap.containsKey(currentChar)) &#123;</span><br><span class="line">                // 更新左边界，确保窗口内没有重复字符</span><br><span class="line">                // 取最大值是为了防止左边界向左移动</span><br><span class="line">                left = Math.max(left, charIndexMap.get(currentChar) + 1);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 更新当前字符的最新位置</span><br><span class="line">            charIndexMap.put(currentChar, right);</span><br><span class="line">            </span><br><span class="line">            // 计算当前窗口的长度，并更新最大长度</span><br><span class="line">            maxLength = Math.max(maxLength, right - left + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 测试代码</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LongestSubstringWithoutRepeating solution = new LongestSubstringWithoutRepeating();</span><br><span class="line">        </span><br><span class="line">        // 示例1</span><br><span class="line">        String s1 = &quot;abcabcbb&quot;;</span><br><span class="line">        System.out.println(&quot;输入: &quot; + s1);</span><br><span class="line">        System.out.println(&quot;输出: &quot; + solution.lengthOfLongestSubstring(s1)); // 输出: 3</span><br><span class="line">        </span><br><span class="line">        // 示例2</span><br><span class="line">        String s2 = &quot;bbbbb&quot;;</span><br><span class="line">        System.out.println(&quot;输入: &quot; + s2);</span><br><span class="line">        System.out.println(&quot;输出: &quot; + solution.lengthOfLongestSubstring(s2)); // 输出: 1</span><br><span class="line">        </span><br><span class="line">        // 示例3</span><br><span class="line">        String s3 = &quot;pwwkew&quot;;</span><br><span class="line">        System.out.println(&quot;输入: &quot; + s3);</span><br><span class="line">        System.out.println(&quot;输出: &quot; + solution.lengthOfLongestSubstring(s3)); // 输出: 3</span><br><span class="line">        </span><br><span class="line">        // 额外测试用例</span><br><span class="line">        String s4 = &quot;abcde&quot;;</span><br><span class="line">        System.out.println(&quot;输入: &quot; + s4);</span><br><span class="line">        System.out.println(&quot;输出: &quot; + solution.lengthOfLongestSubstring(s4)); // 输出: 5</span><br><span class="line">        </span><br><span class="line">        String s5 = &quot;aab&quot;;</span><br><span class="line">        System.out.println(&quot;输入: &quot; + s5);</span><br><span class="line">        System.out.println(&quot;输出: &quot; + solution.lengthOfLongestSubstring(s5)); // 输出: 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">初始状态: left=0, maxLength=0, charIndexMap=&#123;&#125;</span><br><span class="line"></span><br><span class="line">第1步: right=0, char=&#x27;a&#x27;</span><br><span class="line">  charIndexMap中没有&#x27;a&#x27;，直接添加</span><br><span class="line">  charIndexMap=&#123;&#x27;a&#x27;:0&#125;</span><br><span class="line">  当前窗口长度=1，maxLength=1</span><br><span class="line"></span><br><span class="line">第2步: right=1, char=&#x27;b&#x27;</span><br><span class="line">  charIndexMap中没有&#x27;b&#x27;，直接添加</span><br><span class="line">  charIndexMap=&#123;&#x27;a&#x27;:0, &#x27;b&#x27;:1&#125;</span><br><span class="line">  当前窗口长度=2，maxLength=2</span><br><span class="line"></span><br><span class="line">第3步: right=2, char=&#x27;c&#x27;</span><br><span class="line">  charIndexMap中没有&#x27;c&#x27;，直接添加</span><br><span class="line">  charIndexMap=&#123;&#x27;a&#x27;:0, &#x27;b&#x27;:1, &#x27;c&#x27;:2&#125;</span><br><span class="line">  当前窗口长度=3，maxLength=3</span><br><span class="line"></span><br><span class="line">第4步: right=3, char=&#x27;a&#x27;</span><br><span class="line">  charIndexMap中有&#x27;a&#x27;，位置是0</span><br><span class="line">  更新left = max(0, 0+1) = 1</span><br><span class="line">  更新charIndexMap中&#x27;a&#x27;的位置为3</span><br><span class="line">  charIndexMap=&#123;&#x27;a&#x27;:3, &#x27;b&#x27;:1, &#x27;c&#x27;:2&#125;</span><br><span class="line">  当前窗口长度=3，maxLength=3</span><br><span class="line"></span><br><span class="line">第5步: right=4, char=&#x27;b&#x27;</span><br><span class="line">  charIndexMap中有&#x27;b&#x27;，位置是1</span><br><span class="line">  更新left = max(1, 1+1) = 2</span><br><span class="line">  更新charIndexMap中&#x27;b&#x27;的位置为4</span><br><span class="line">  charIndexMap=&#123;&#x27;a&#x27;:3, &#x27;b&#x27;:4, &#x27;c&#x27;:2&#125;</span><br><span class="line">  当前窗口长度=3，maxLength=3</span><br><span class="line"></span><br><span class="line">第6步: right=5, char=&#x27;c&#x27;</span><br><span class="line">  charIndexMap中有&#x27;c&#x27;，位置是2</span><br><span class="line">  更新left = max(2, 2+1) = 3</span><br><span class="line">  更新charIndexMap中&#x27;c&#x27;的位置为5</span><br><span class="line">  charIndexMap=&#123;&#x27;a&#x27;:3, &#x27;b&#x27;:4, &#x27;c&#x27;:5&#125;</span><br><span class="line">  当前窗口长度=3，maxLength=3</span><br><span class="line"></span><br><span class="line">第7步: right=6, char=&#x27;b&#x27;</span><br><span class="line">  charIndexMap中有&#x27;b&#x27;，位置是4</span><br><span class="line">  更新left = max(3, 4+1) = 5</span><br><span class="line">  更新charIndexMap中&#x27;b&#x27;的位置为6</span><br><span class="line">  charIndexMap=&#123;&#x27;a&#x27;:3, &#x27;b&#x27;:6, &#x27;c&#x27;:5&#125;</span><br><span class="line">  当前窗口长度=2，maxLength=3</span><br><span class="line"></span><br><span class="line">第8步: right=7, char=&#x27;b&#x27;</span><br><span class="line">  charIndexMap中有&#x27;b&#x27;，位置是6</span><br><span class="line">  更新left = max(5, 6+1) = 7</span><br><span class="line">  更新charIndexMap中&#x27;b&#x27;的位置为7</span><br><span class="line">  charIndexMap=&#123;&#x27;a&#x27;:3, &#x27;b&#x27;:7, &#x27;c&#x27;:5&#125;</span><br><span class="line">  当前窗口长度=1，maxLength=3</span><br><span class="line"></span><br><span class="line">最终结果: 3</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>法算day7</title>
      <link href="/lief/%E6%B3%95%E7%AE%97day7/"/>
      <url>/lief/%E6%B3%95%E7%AE%97day7/</url>
      
        <content type="html"><![CDATA[<div class="video-container">[up主专用，视频内嵌代码贴在这]</div><style>.video-container {    position: relative;    width: 100%;    padding-top: 56.25%; /* 16:9 aspect ratio (height/width = 9/16 * 100%) */}.video-container iframe {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;}</style><h1 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h1><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h4><img src="/lief/%E6%B3%95%E7%AE%97day7/PixPin_2025-11-23_13-23-35.png" class=""><p>输入：height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出：6<br>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </p><h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4><p>输入：height &#x3D; [4,2,0,3,2,5]<br>输出：9</p><p>提示：<br>n &#x3D;&#x3D; height.length<br>1 &lt;&#x3D; n &lt;&#x3D; 2 * 104<br>0 &lt;&#x3D; height[i] &lt;&#x3D; 105</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>这个问题的关键在于理解：每个位置能接的雨水量取决于它左右两边的最高柱子。</p><ol><li><p>对于每个位置，我们需要知道它左边的最高柱子和右边的最高柱子</p></li><li><p>这两个最高柱子中较矮的那个决定了水位的高度</p></li><li><p>水位高度减去当前位置的高度，就是这个位置能接的雨水量</p></li></ol><p>这种方法的时间复杂度是O(n)，因为我们只需要遍历数组三次（计算左边最大值、右边最大值和计算总雨水量）。空间复杂度是O(n)，因为我们使用了两个辅助数组。</p><h3 id="举例说明（动态规划法）"><a href="#举例说明（动态规划法）" class="headerlink" title="举例说明（动态规划法）"></a>举例说明（动态规划法）</h3><p>对于数组 [0,1,0,2,1,0,1,3,2,1,2,1]：</p><img src="/lief/%E6%B3%95%E7%AE%97day7/PixPin_2025-11-23_13-23-35.png" class=""><p>位置0：高度为0，左边最大值是0，右边最大值是3，能接的水量是min(0,3)-0&#x3D;0<br>位置1：高度为1，左边最大值是1，右边最大值是3，能接的水量是min(1,3)-1&#x3D;0<br>位置2：高度为0，左边最大值是1，右边最大值是3，能接的水量是min(1,3)-0&#x3D;1<br>位置3：高度为2，左边最大值是2，右边最大值是3，能接的水量是min(2,3)-2&#x3D;0<br>位置4：高度为1，左边最大值是2，右边最大值是3，能接的水量是min(2,3)-1&#x3D;1<br>位置5：高度为0，左边最大值是2，右边最大值是3，能接的水量是min(2,3)-0&#x3D;2<br>位置6：高度为1，左边最大值是2，右边最大值是3，能接的水量是min(2,3)-1&#x3D;1<br>位置7：高度为3，左边最大值是3，右边最大值是3，能接的水量是min(3,3)-3&#x3D;0<br>位置8：高度为2，左边最大值是3，右边最大值是2，能接的水量是min(2,3)-2&#x3D;0<br>位置9：高度为1，左边最大值是3，右边最大值是2，能接的水量是min(2,3)-1&#x3D;1<br>位置10：高度为2，左边最大值是3，右边最大值是2，能接的水量是min(2,3)-2&#x3D;0<br>位置11：高度为1，左边最大值是3，右边最大值是1，能接的水量是min(3,1)-1&#x3D;0</p><p>将所有位置的雨水量相加，就得到总雨水量6。</p><h3 id="Java版（动态规划法）"><a href="#Java版（动态规划法）" class="headerlink" title="Java版（动态规划法）"></a>Java版（动态规划法）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 时间复杂度：O(n)，空间复杂度：O(n)</span><br><span class="line">int[] leftMax = new int[n];  // 创建左最大值数组，用于存储每个位置左侧的最大高度</span><br><span class="line">int[] rightMax = new int[n]; // 创建右最大值数组，用于存储每个位置右侧的最大高度</span><br><span class="line"></span><br><span class="line">// 预处理左最大值数组</span><br><span class="line">// 从左到右遍历，计算每个位置左侧的最大高度</span><br><span class="line">for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">    // leftMax[i] 等于前一个位置的左最大值和前一个柱子高度的较大值</span><br><span class="line">    leftMax[i] = Math.max(leftMax[i-1], height[i-1]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 预处理右最大值数组</span><br><span class="line">// 从右到左遍历，计算每个位置右侧的最大高度</span><br><span class="line">for (int i = n-2; i &gt;= 0; i--) &#123;</span><br><span class="line">    // rightMax[i] 等于后一个位置的右最大值和后一个柱子高度的较大值</span><br><span class="line">    rightMax[i] = Math.max(rightMax[i+1], height[i+1]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 计算每个位置能接住的雨水量</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">    // 当前位置能接住的雨水量由左右两侧最大高度的较小值决定</span><br><span class="line">    int minHeight = Math.min(leftMax[i], rightMax[i]);</span><br><span class="line">    // 只有当最小高度大于当前柱子高度时，才能接住雨水</span><br><span class="line">    if (minHeight &gt; height[i]) &#123;</span><br><span class="line">        // 雨水量 = 左右最大高度较小值 - 当前柱子高度</span><br><span class="line">        water += minHeight - height[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ 说明：</p><ol><li>时间复杂度：O(n)</li><li>空间复杂度是 O(n)，需要额外的O(n)空间来存储左右最大高度数组</li></ol><h3 id="java版（方法一：双指针法）"><a href="#java版（方法一：双指针法）" class="headerlink" title="java版（方法一：双指针法）"></a>java版（方法一：双指针法）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public class TrapRainWater &#123;</span><br><span class="line">    public int trap(int[] height) &#123;</span><br><span class="line">        // 如果数组为空或长度小于3，无法接住雨水，直接返回0</span><br><span class="line">        if (height == null || height.length &lt; 3) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int left = 0; // 左指针，从数组最左边开始</span><br><span class="line">        int right = height.length - 1; // 右指针，从数组最右边开始</span><br><span class="line">        int leftMax = 0; // 记录左边遇到的最大高度</span><br><span class="line">        int rightMax = 0; // 记录右边遇到的最大高度</span><br><span class="line">        int water = 0; // 记录总的接雨水量</span><br><span class="line">        </span><br><span class="line">        // 使用双指针法，从数组两端向中间遍历</span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            // 如果左边的高度小于右边的高度</span><br><span class="line">            if (height[left] &lt; height[right]) &#123;</span><br><span class="line">                // 如果当前高度大于等于左边最大高度，更新左边最大高度</span><br><span class="line">                if (height[left] &gt;= leftMax) &#123;</span><br><span class="line">                    leftMax = height[left];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 否则，当前位置可以接住雨水，水量为左边最大高度减去当前高度</span><br><span class="line">                    water += leftMax - height[left];</span><br><span class="line">                &#125;</span><br><span class="line">                // 左指针向右移动</span><br><span class="line">                left++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 如果右边的高度小于等于左边的高度</span><br><span class="line">                // 如果当前高度大于等于右边最大高度，更新右边最大高度</span><br><span class="line">                if (height[right] &gt;= rightMax) &#123;</span><br><span class="line">                    rightMax = height[right];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 否则，当前位置可以接住雨水，水量为右边最大高度减去当前高度</span><br><span class="line">                    water += rightMax - height[right];</span><br><span class="line">                &#125;</span><br><span class="line">                // 右指针向左移动</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return water;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 测试代码</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TrapRainWater solution = new TrapRainWater();</span><br><span class="line">        </span><br><span class="line">        // 示例1</span><br><span class="line">        int[] height1 = &#123;0,1,0,2,1,0,1,3,2,1,2,1&#125;;</span><br><span class="line">        System.out.println(solution.trap(height1)); // 输出: 6</span><br><span class="line">        </span><br><span class="line">        // 示例2</span><br><span class="line">        int[] height2 = &#123;4,2,0,3,2,5&#125;;</span><br><span class="line">        System.out.println(solution.trap(height2)); // 输出: 9</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ 说明：</p><ol><li>时间复杂度：O(n)</li><li>空间复杂度是 O(1)</li></ol><h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>对于数组 [0,1,0,2,1,0,1,3,2,1,2,1]：</p><img src="/lief/%E6%B3%95%E7%AE%97day7/PixPin_2025-11-23_13-23-35.png" class=""><ol start="0"><li>初始状态<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">height = [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">索引:     0 1 2 3 4 5 6 7 8 9 10 11</span><br><span class="line">left = 0, right = 11</span><br><span class="line">leftMax = 0, rightMax = 0</span><br><span class="line">water = 0</span><br></pre></td></tr></table></figure></li><li>第1步：比较 height[0] 和 height[11]<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">left=0, right=11</span><br><span class="line">height[0]=0, height[11]=1</span><br><span class="line">0 &lt; 1 → 走if分支</span><br><span class="line">height[0]=0 &gt;= leftMax=0? 是 → 更新leftMax=0</span><br><span class="line">left++ → left=1</span><br><span class="line">结果: leftMax=0, rightMax=0, water=0</span><br></pre></td></tr></table></figure></li><li>第2步：比较 height[1] 和 height[11]<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">left=1, right=11</span><br><span class="line">height[1]=1, height[11]=1</span><br><span class="line">1 &gt;= 1 → 走else分支</span><br><span class="line">height[11]=1 &gt;= rightMax=0? 是 → 更新rightMax=1</span><br><span class="line">right-- → right=10</span><br><span class="line">结果: leftMax=0, rightMax=1, water=0</span><br></pre></td></tr></table></figure></li><li>第3步：比较 height[1] 和 height[10]<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">left=1, right=10</span><br><span class="line">height[1]=1, height[10]=2</span><br><span class="line">1 &lt; 2 → 走if分支</span><br><span class="line">height[1]=1 &gt;= leftMax=0? 是 → 更新leftMax=1</span><br><span class="line">left++ → left=2</span><br><span class="line">结果: leftMax=1, rightMax=1, water=0</span><br></pre></td></tr></table></figure></li><li>第4步：比较 height[2] 和 height[10]<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">left=2, right=10</span><br><span class="line">height[2]=0, height[10]=2</span><br><span class="line">0 &lt; 2 → 走if分支</span><br><span class="line">height[2]=0 &gt;= leftMax=1? 否 → water += 1-0=1</span><br><span class="line">left++ → left=3</span><br><span class="line">结果: leftMax=1, rightMax=1, water=1</span><br></pre></td></tr></table></figure></li><li>第5步：比较 height[3] 和 height[10]<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">left=3, right=10</span><br><span class="line">height[3]=2, height[10]=2</span><br><span class="line">2 &gt;= 2 → 走else分支</span><br><span class="line">height[10]=2 &gt;= rightMax=1? 是 → 更新rightMax=2</span><br><span class="line">right-- → right=9</span><br><span class="line">结果: leftMax=1, rightMax=2, water=1</span><br></pre></td></tr></table></figure></li><li>第6步：比较 height[3] 和 height[9]<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">left=3, right=9</span><br><span class="line">height[3]=2, height[9]=1</span><br><span class="line">2 &gt;= 1 → 走else分支</span><br><span class="line">height[9]=1 &gt;= rightMax=2? 否 → water += 2-1=1</span><br><span class="line">right-- → right=8</span><br><span class="line">结果: leftMax=1, rightMax=2, water=2</span><br></pre></td></tr></table></figure></li><li>第7步：比较 height[3] 和 height[8<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">left=3, right=8</span><br><span class="line">height[3]=2, height[8]=2</span><br><span class="line">2 &gt;= 2 → 走else分支</span><br><span class="line">height[8]=2 &gt;= rightMax=2? 是 → 更新rightMax=2</span><br><span class="line">right-- → right=7</span><br><span class="line">结果: leftMax=1, rightMax=2, water=2</span><br></pre></td></tr></table></figure></li><li>第8步：比较 height[3] 和 height[7]<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">left=3, right=7</span><br><span class="line">height[3]=2, height[7]=3</span><br><span class="line">2 &lt; 3 → 走if分支</span><br><span class="line">height[3]=2 &gt;= leftMax=1? 是 → 更新leftMax=2</span><br><span class="line">left++ → left=4</span><br><span class="line">结果: leftMax=2, rightMax=2, water=2</span><br></pre></td></tr></table></figure></li><li>第9步：比较 height[4] 和 height[7]<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">left=4, right=7</span><br><span class="line">height[4]=1, height[7]=3</span><br><span class="line">1 &lt; 3 → 走if分支</span><br><span class="line">height[4]=1 &gt;= leftMax=2? 否 → water += 2-1=1</span><br><span class="line">left++ → left=5</span><br><span class="line">结果: leftMax=2, rightMax=2, water=3</span><br></pre></td></tr></table></figure></li><li>第10步：比较 height[5] 和 height[7]<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">left=5, right=7</span><br><span class="line">height[5]=0, height[7]=3</span><br><span class="line">0 &lt; 3 → 走if分支</span><br><span class="line">height[5]=0 &gt;= leftMax=2? 否 → water += 2-0=2</span><br><span class="line">left++ → left=6</span><br><span class="line">结果: leftMax=2, rightMax=2, water=5</span><br></pre></td></tr></table></figure></li><li>第11步：比较 height[6] 和 height[7]<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">left=6, right=7</span><br><span class="line">height[6]=1, height[7]=3</span><br><span class="line">1 &lt; 3 → 走if分支</span><br><span class="line">height[6]=1 &gt;= leftMax=2? 否 → water += 2-1=1</span><br><span class="line">left++ → left=7</span><br><span class="line">结果: leftMax=2, rightMax=2, water=6</span><br></pre></td></tr></table></figure></li><li>第12步：left&#x3D;7, right&#x3D;7<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">left &gt;= right → 循环结束</span><br><span class="line">最终结果: water = 6</span><br></pre></td></tr></table></figure></li></ol><h3 id="python版（双指针法）"><a href="#python版（双指针法）" class="headerlink" title="python版（双指针法）"></a>python版（双指针法）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">def trap(height):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    计算接雨水的总量</span><br><span class="line">    使用双指针法，从数组的两端向中间移动</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 如果数组为空或长度小于3，无法接住雨水，直接返回0</span><br><span class="line">    if not height or len(height) &lt; 3:</span><br><span class="line">        return 0</span><br><span class="line">    </span><br><span class="line">    # 初始化左右指针</span><br><span class="line">    left = 0</span><br><span class="line">    right = len(height) - 1</span><br><span class="line">    </span><br><span class="line">    # 记录左右两边的最大高度</span><br><span class="line">    left_max = 0</span><br><span class="line">    right_max = 0</span><br><span class="line">    </span><br><span class="line">    # 记录总雨水量</span><br><span class="line">    water = 0</span><br><span class="line">    </span><br><span class="line">    # 当左指针小于右指针时循环</span><br><span class="line">    while left &lt; right:</span><br><span class="line">        # 如果左边的高度小于右边的高度</span><br><span class="line">        if height[left] &lt; height[right]:</span><br><span class="line">            # 如果当前左边高度大于等于左边最大高度</span><br><span class="line">            if height[left] &gt;= left_max:</span><br><span class="line">                # 更新左边最大高度</span><br><span class="line">                left_max = height[left]</span><br><span class="line">            else:</span><br><span class="line">                # 计算当前位置能接的雨水量并累加</span><br><span class="line">                # 雨水量 = 左边最大高度 - 当前高度</span><br><span class="line">                water += left_max - height[left]</span><br><span class="line">            # 左指针右移</span><br><span class="line">            left += 1</span><br><span class="line">        else:</span><br><span class="line">            # 如果当前右边高度大于等于右边最大高度</span><br><span class="line">            if height[right] &gt;= right_max:</span><br><span class="line">                # 更新右边最大高度</span><br><span class="line">                right_max = height[right]</span><br><span class="line">            else:</span><br><span class="line">                # 计算当前位置能接的雨水量并累加</span><br><span class="line">                # 雨水量 = 右边最大高度 - 当前高度</span><br><span class="line">                water += right_max - height[right]</span><br><span class="line">            # 右指针左移</span><br><span class="line">            right -= 1</span><br><span class="line">    </span><br><span class="line">    return water</span><br><span class="line"></span><br><span class="line"># 测试代码</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    # 示例1</span><br><span class="line">    height1 = [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">    print(trap(height1))  # 输出: 6</span><br><span class="line">    </span><br><span class="line">    # 示例2</span><br><span class="line">    height2 = [4,2,0,3,2,5]</span><br><span class="line">    print(trap(height2))  # 输出: 9</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>法算day6</title>
      <link href="/lief/%E6%B3%95%E7%AE%97day6/"/>
      <url>/lief/%E6%B3%95%E7%AE%97day6/</url>
      
        <content type="html"><![CDATA[<h1 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h1><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i !&#x3D; j、i !&#x3D; k 且 j !&#x3D; k ，同时还满足 nums[i] + nums[j] + nums[k] &#x3D;&#x3D; 0 。请你返回所有和为 0 且不重复的三元组。<br><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例 1：</strong><br>输入：nums &#x3D; [-1,0,1,2,-1,-4]<br>输出：[[-1,-1,2],[-1,0,1]]<br>解释：<br>nums[0] + nums[1] + nums[2] &#x3D; (-1) + 0 + 1 &#x3D; 0 。<br>nums[1] + nums[2] + nums[4] &#x3D; 0 + 1 + (-1) &#x3D; 0 。<br>nums[0] + nums[3] + nums[4] &#x3D; (-1) + 2 + (-1) &#x3D; 0 。<br>不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。<br><strong>注意，</strong>输出的顺序和三元组的顺序并不重要。</p><p><strong>示例 2：</strong><br>输入：nums &#x3D; [0,1,1]<br>输出：[]<br>解释：唯一可能的三元组和不为 0 。</p><p><strong>示例 3：</strong><br>输入：nums &#x3D; [0,0,0]<br>输出：[[0,0,0]]<br>解释：唯一可能的三元组和为 0 。</p><p>提示：<br>3 &lt;&#x3D; nums.length &lt;&#x3D; 3000<br>-105 &lt;&#x3D; nums[i] &lt;&#x3D; 105</p><h3 id="python版（排序-双指针）"><a href="#python版（排序-双指针）" class="headerlink" title="python版（排序+双指针）"></a>python版（排序+双指针）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">def threeSum(nums):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    寻找所有和为0的不重复三元组</span><br><span class="line">    使用排序 + 双指针的方法</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 先对数组进行排序，方便后续去重和双指针操作</span><br><span class="line">    nums.sort()</span><br><span class="line">    n = len(nums)</span><br><span class="line">    result = []  # 存储结果列表</span><br><span class="line">    </span><br><span class="line">    # 遍历数组，固定第一个数</span><br><span class="line">    for i in range(n - 2):  # 只需要遍历到倒数第三个数</span><br><span class="line">        # 如果当前数大于0，由于数组已排序，后面的数都大于0，不可能和为0，直接退出</span><br><span class="line">        if nums[i] &gt; 0:</span><br><span class="line">            break</span><br><span class="line">        </span><br><span class="line">        # 跳过重复的第一个数，避免重复三元组</span><br><span class="line">        if i &gt; 0 and nums[i] == nums[i - 1]:</span><br><span class="line">            continue</span><br><span class="line">        </span><br><span class="line">        # 设置双指针：left从i+1开始，right从末尾开始</span><br><span class="line">        left = i + 1</span><br><span class="line">        right = n - 1</span><br><span class="line">        </span><br><span class="line">        # 双指针向中间移动</span><br><span class="line">        while left &lt; right:</span><br><span class="line">            # 计算当前三个数的和</span><br><span class="line">            total = nums[i] + nums[left] + nums[right]</span><br><span class="line">            </span><br><span class="line">            if total &lt; 0:</span><br><span class="line">                # 和太小，左指针右移（因为数组已排序，右移会增大和）</span><br><span class="line">                left += 1</span><br><span class="line">            elif total &gt; 0:</span><br><span class="line">                # 和太大，右指针左移（因为数组已排序，左移会减小和）</span><br><span class="line">                right -= 1</span><br><span class="line">            else:</span><br><span class="line">                # 找到和为0的三元组，添加到结果中</span><br><span class="line">                result.append([nums[i], nums[left], nums[right]])</span><br><span class="line">                </span><br><span class="line">                # 跳过重复的left值</span><br><span class="line">                while left &lt; right and nums[left] == nums[left + 1]:</span><br><span class="line">                    left += 1</span><br><span class="line">                # 跳过重复的right值</span><br><span class="line">                while left &lt; right and nums[right] == nums[right - 1]:</span><br><span class="line">                    right -= 1</span><br><span class="line">                </span><br><span class="line">                # 移动双指针继续寻找</span><br><span class="line">                left += 1</span><br><span class="line">                right -= 1</span><br><span class="line">    </span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line"># 测试代码</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    # 示例1</span><br><span class="line">    nums1 = [-1, 0, 1, 2, -1, -4]</span><br><span class="line">    print(threeSum(nums1))  # 输出: [[-1, -1, 2], [-1, 0, 1]]</span><br><span class="line">    </span><br><span class="line">    # 示例2</span><br><span class="line">    nums2 = [0, 1, 1]</span><br><span class="line">    print(threeSum(nums2))  # 输出: []</span><br><span class="line">    </span><br><span class="line">    # 示例3</span><br><span class="line">    nums3 = [0, 0, 0]</span><br><span class="line">    print(threeSum(nums3))  # 输出: [[0, 0, 0]]</span><br></pre></td></tr></table></figure><p>✅ 说明：</p><ol><li>时间复杂度：排序操作：nums.sort() 使用 Timsort 算法，时间复杂度为 O(n log n)<br> 外层循环：for i in range(n - 2) 执行 O(n) 次<br> 内层双指针循环：while left &lt; right 在最坏情况下（当数组元素全部相同时）会遍历整个剩余数组，每次执行 O(n) 次操作<br> 总体时间复杂度：<br> 最坏情况：O(n log n) + O(n) × O(n) &#x3D; O(n²)<br> 最好情况：O(n log n) + O(n) × O(1) &#x3D; O(n log n)（当数组已排序且没有有效三元组时）<br> 平均情况：O(n²)</li><li>空间复杂度：O(n)（主要由排序算法所需空间决定）</li></ol><h3 id="示例1详解"><a href="#示例1详解" class="headerlink" title="示例1详解"></a>示例1详解</h3><div class="video-container">[<iframe src="//player.bilibili.com/player.html?isOutside=true&aid=115585505631194&bvid=BV1wjyuBzE7L&cid=34149697832&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe>]</div><style>.video-container {    position: relative;    width: 100%;    padding-top: 56.25%; /* 16:9 aspect ratio (height/width = 9/16 * 100%) */}.video-container iframe {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;}</style><h3 id="java版"><a href="#java版" class="headerlink" title="java版"></a>java版</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class ThreeSum &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;</span><br><span class="line">        // 创建结果列表，用于存储所有满足条件的三元组</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        // 如果数组为空或长度小于3，直接返回空结果</span><br><span class="line">        if (nums == null || nums.length &lt; 3) &#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 对数组进行排序，这是解决三数之和问题的关键步骤</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        </span><br><span class="line">        // 遍历数组，固定第一个数</span><br><span class="line">        for (int i = 0; i &lt; nums.length - 2; i++) &#123;</span><br><span class="line">            // 如果当前数大于0，由于数组已排序，后面的数都大于0，三数之和不可能为0，直接结束循环</span><br><span class="line">            if (nums[i] &gt; 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 跳过重复的元素，避免出现重复的三元组</span><br><span class="line">            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 使用双指针法，在i之后的子数组中寻找另外两个数</span><br><span class="line">            int left = i + 1;  // 左指针指向i的下一个位置</span><br><span class="line">            int right = nums.length - 1;  // 右指针指向数组末尾</span><br><span class="line">            </span><br><span class="line">            // 当左右指针没有相遇时，继续寻找</span><br><span class="line">            while (left &lt; right) &#123;</span><br><span class="line">                // 计算当前三个数的和</span><br><span class="line">                int sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                </span><br><span class="line">                if (sum == 0) &#123;</span><br><span class="line">                    // 如果和为0，找到一个满足条件的三元组</span><br><span class="line">                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));</span><br><span class="line">                    </span><br><span class="line">                    // 跳过重复的左指针元素</span><br><span class="line">                    while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 跳过重复的右指针元素</span><br><span class="line">                    while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    // 移动指针继续寻找其他可能的组合</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; else if (sum &lt; 0) &#123;</span><br><span class="line">                    // 如果和小于0，说明需要更大的数，左指针右移</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 如果和大于0，说明需要更小的数，右指针左移</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 测试代码</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ThreeSum solution = new ThreeSum();</span><br><span class="line">        </span><br><span class="line">        // 示例1</span><br><span class="line">        int[] nums1 = &#123;-1, 0, 1, 2, -1, -4&#125;;</span><br><span class="line">        System.out.println(solution.threeSum(nums1)); // 输出: [[-1, -1, 2], [-1, 0, 1]]</span><br><span class="line">        </span><br><span class="line">        // 示例2</span><br><span class="line">        int[] nums2 = &#123;0, 1, 1&#125;;</span><br><span class="line">        System.out.println(solution.threeSum(nums2)); // 输出: []</span><br><span class="line">        </span><br><span class="line">        // 示例3</span><br><span class="line">        int[] nums3 = &#123;0, 0, 0&#125;;</span><br><span class="line">        System.out.println(solution.threeSum(nums3)); // 输出: [[0, 0, 0]]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>法算day5</title>
      <link href="/lief/%E6%B3%95%E7%AE%97day5/"/>
      <url>/lief/%E6%B3%95%E7%AE%97day5/</url>
      
        <content type="html"><![CDATA[<h1 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h1><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。<br>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br>返回容器可以储存的最大水量。<br>✅ 说明：你不能倾斜容器。</p><h4 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h4><img src="/lief/%E6%B3%95%E7%AE%97day5/PixPin_2025-11-20_09-53-21.png" class=""><p>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49<br>解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><p>示例 2：<br>输入：height &#x3D; [1,1]<br>输出：1</p><p>提示：<br>n &#x3D;&#x3D; height.length<br>2 &lt;&#x3D; n &lt;&#x3D; 105<br>0 &lt;&#x3D; height[i] &lt;&#x3D; 104</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>这个问题是要找到两条垂直线，使得它们与x轴构成的容器能容纳最多的水。容器的容量由两个因素决定：<br>宽度：两条线之间的水平距离<br>高度：两条线中较短的那条线的高度<br>所以容量公式为：容量 &#x3D; 距离 × min(左线高度, 右线高度)</p><h3 id="为什么移动较短的线？"><a href="#为什么移动较短的线？" class="headerlink" title="为什么移动较短的线？"></a>为什么移动较短的线？</h3><p>这是算法的关键点：<br>容器的容量由较短边的高度决定<br>每次移动指针，宽度都会减小<br>如果移动较长的边，容量只会更小（因为高度不会增加，宽度减小）<br>如果移动较短的边，有可能找到更高的边，从而增加容量</p><h3 id="java版（双指针法）"><a href="#java版（双指针法）" class="headerlink" title="java版（双指针法）"></a>java版（双指针法）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class ContainerWithMostWater &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 测试用例1</span><br><span class="line">        int[] height1 = &#123;1,8,6,2,5,4,8,3,7&#125;;</span><br><span class="line">        System.out.println(&quot;测试1结果: &quot; + maxArea(height1)); // 应该输出49</span><br><span class="line">        </span><br><span class="line">        // 测试用例2</span><br><span class="line">        int[] height2 = &#123;1,1&#125;;</span><br><span class="line">        System.out.println(&quot;测试2结果: &quot; + maxArea(height2)); // 应该输出1</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static int maxArea(int[] height) &#123;</span><br><span class="line">        // 初始化左右指针，分别指向数组的首尾</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = height.length - 1;</span><br><span class="line">        // 记录最大面积</span><br><span class="line">        int maxArea = 0;</span><br><span class="line">        </span><br><span class="line">        // 当左右指针没有相遇时，继续循环</span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            // 计算当前两条线之间的宽度</span><br><span class="line">            int width = right - left;</span><br><span class="line">            // 容器的高度取决于较短的那条线</span><br><span class="line">            int currentHeight = Math.min(height[left], height[right]);</span><br><span class="line">            // 计算当前面积</span><br><span class="line">            int currentArea = width * currentHeight;</span><br><span class="line">            // 更新最大面积</span><br><span class="line">            maxArea = Math.max(maxArea, currentArea);</span><br><span class="line">            </span><br><span class="line">            // 关键步骤：移动较短的那条线对应的指针</span><br><span class="line">            // 因为移动较长的线不会增加容量，而移动较短的线有可能找到更高的线</span><br><span class="line">            if (height[left] &lt; height[right]) &#123;</span><br><span class="line">                left++;  // 左指针右移</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                right--; // 右指针左移</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ 说明：</p><ol><li>时间复杂度：O(n) - 我们只需要遍历数组一次</li><li>空间复杂度：O(1) - 只使用了常数级别的额外空间</li></ol><h3 id="python版"><a href="#python版" class="headerlink" title="python版"></a>python版</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">def maxArea(height):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    计算容器能容纳的最大水量</span><br><span class="line">    使用双指针法，从数组的两端向中间移动</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 初始化左指针和右指针</span><br><span class="line">    left = 0</span><br><span class="line">    right = len(height) - 1</span><br><span class="line">    # 初始化最大面积</span><br><span class="line">    max_area = 0</span><br><span class="line">    </span><br><span class="line">    # 当左指针小于右指针时循环</span><br><span class="line">    while left &lt; right:</span><br><span class="line">        # 计算当前左右指针构成的容器的面积</span><br><span class="line">        # 面积 = 宽度 * 高度，高度取左右指针中较小的那个</span><br><span class="line">        current_area = (right - left) * min(height[left], height[right])</span><br><span class="line">        # 更新最大面积</span><br><span class="line">        max_area = max(max_area, current_area)</span><br><span class="line">        </span><br><span class="line">        # 移动高度较小的指针，因为移动高度较大的指针不会增加面积</span><br><span class="line">        if height[left] &lt; height[right]:</span><br><span class="line">            left += 1  # 左指针右移</span><br><span class="line">        else:</span><br><span class="line">            right -= 1  # 右指针左移</span><br><span class="line">    </span><br><span class="line">    return max_area</span><br><span class="line"></span><br><span class="line"># 测试代码</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    # 示例1</span><br><span class="line">    height1 = [1,8,6,2,5,4,8,3,7]</span><br><span class="line">    print(maxArea(height1))  # 输出: 49</span><br><span class="line">    </span><br><span class="line">    # 示例2</span><br><span class="line">    height2 = [1,1]</span><br><span class="line">    print(maxArea(height2))  # 输出: 1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>法算day4</title>
      <link href="/lief/%E6%B3%95%E7%AE%97day4/"/>
      <url>/lief/%E6%B3%95%E7%AE%97day4/</url>
      
        <content type="html"><![CDATA[<h1 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a>移动零</h1><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意 ：必须在不复制数组的情况下原地对数组进行操作。</strong></p><p>示例 1:<br>输入: nums &#x3D; [0,1,0,3,12]<br>输出: [1,3,12,0,0]</p><p>示例 2:<br>输入: nums &#x3D; [0]<br>输出: [0]</p><p>提示:<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 104<br>-231 &lt;&#x3D; nums[i] &lt;&#x3D; 231 - 1</p><h3 id="java版"><a href="#java版" class="headerlink" title="java版"></a>java版</h3><h4 id="方法一：双指针法"><a href="#方法一：双指针法" class="headerlink" title="方法一：双指针法"></a>方法一：双指针法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void moveZeroes(int[] nums) &#123;</span><br><span class="line">        // 边界情况检查：如果数组为空或长度为0，直接返回</span><br><span class="line">        if (nums == null || nums.length == 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 使用双指针法</span><br><span class="line">        // left指针：指向当前应该放置非零元素的位置</span><br><span class="line">        int left = 0;</span><br><span class="line">        </span><br><span class="line">        // 遍历数组</span><br><span class="line">        for (int right = 0; right &lt; nums.length; right++) &#123;</span><br><span class="line">            // 如果当前元素不为0</span><br><span class="line">            if (nums[right] != 0) &#123;</span><br><span class="line">                // 将非零元素移动到left指针的位置</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                // 如果left和right不是同一个位置，说明移动了元素    </span><br><span class="line">                // 需要将原位置设置为0（避免重复）                        </span><br><span class="line">                if (left != right) &#123;</span><br><span class="line">                    nums[right] = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                // left指针向右移动，准备放置下一个非零元素</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果当前元素为0，left指针不动，right指针继续向右移动</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ 说明：</p><ol><li>left 指针：记录下一个非零元素应该放置的位置<br>right 指针：遍历整个数组，寻找非零元素</li><li>时间复杂度：O(n)，只需要遍历数组一次（或两次）</li><li>空间复杂度：O(1)，只使用了常数级别的额外空间</li></ol><h2 id="额外补充-增强for循环有一个严重缺陷！"><a href="#额外补充-增强for循环有一个严重缺陷！" class="headerlink" title="额外补充-增强for循环有一个严重缺陷！"></a>额外补充-增强for循环有一个严重缺陷！</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int[] nums = &#123;0, 1, 0, 3, 12&#125;;</span><br><span class="line"></span><br><span class="line">// 使用增强for循环（有问题！）</span><br><span class="line">for (int num : nums) &#123;</span><br><span class="line">    if (num != 0) &#123;</span><br><span class="line">        nums[insertPos] = num;  // 这里会修改数组！</span><br><span class="line">        insertPos++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">初始: [0, 1, 0, 3, 12]</span><br><span class="line">第1次循环: num=0 → 跳过</span><br><span class="line">第2次循环: num=1 → nums[0]=1 → 数组变成 [1, 1, 0, 3, 12]</span><br><span class="line">第3次循环: num=0 → 跳过</span><br><span class="line">第4次循环: num=3 → nums[1]=3 → 数组变成 [1, 3, 0, 3, 12]</span><br><span class="line">第5次循环: num=12 → nums[2]=12 → 数组变成 [1, 3, 12, 3, 12]</span><br></pre></td></tr></table></figure><p>增强for循环适合只读操作，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 只读操作 - 适合用增强for循环</span><br><span class="line">int sum = 0;</span><br><span class="line">for (int num : nums) &#123;</span><br><span class="line">    sum += num;  // 不修改数组，只是读取值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 或者打印数组</span><br><span class="line">for (int num : nums) &#123;</span><br><span class="line">    System.out.print(num + &quot; &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ 总结：<br>增强for循环：语法简洁，适合只读遍历<br>传统for循环：功能更强大，可以通过索引修改数组，控制遍历过程</p><h3 id="python版"><a href="#python版" class="headerlink" title="python版"></a>python版</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">def moveZeroes(nums):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    将数组中的所有0移动到末尾，保持非零元素的相对顺序</span><br><span class="line">    </span><br><span class="line">    参数:</span><br><span class="line">    nums: List[int] - 输入的整数列表</span><br><span class="line">    </span><br><span class="line">    思路:</span><br><span class="line">    使用双指针，left指针记录非零元素应该放置的位置</span><br><span class="line">    right指针遍历整个数组</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    left = 0  # left指针：指向下一个非零元素应该放置的位置</span><br><span class="line">    </span><br><span class="line">    # right指针遍历整个数组</span><br><span class="line">    for right in range(len(nums)):</span><br><span class="line">        # 如果当前元素不为0</span><br><span class="line">        if nums[right] != 0:</span><br><span class="line">            # 将非零元素交换到left位置</span><br><span class="line">            nums[left], nums[right] = nums[right], nums[left]</span><br><span class="line">            # left指针向右移动，准备放置下一个非零元素</span><br><span class="line">            left += 1</span><br><span class="line">        # 如果当前元素为0，left指针不动，right指针继续移动</span><br></pre></td></tr></table></figure><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 测试函数</span><br><span class="line">def test_moveZeroes():</span><br><span class="line">    # 测试用例1</span><br><span class="line">    nums1 = [0, 1, 0, 3, 12]</span><br><span class="line">    moveZeroes(nums1)</span><br><span class="line">    print(f&quot;测试1: &#123;nums1&#125;&quot;)  # 应该输出 [1, 3, 12, 0, 0]</span><br><span class="line">    </span><br><span class="line">    # 测试用例2</span><br><span class="line">    nums2 = [0]</span><br><span class="line">    moveZeroes(nums2)</span><br><span class="line">    print(f&quot;测试2: &#123;nums2&#125;&quot;)  # 应该输出 [0]</span><br><span class="line">    </span><br><span class="line">    # 测试用例3</span><br><span class="line">    nums3 = [1, 2, 3, 4, 5]</span><br><span class="line">    moveZeroes(nums3)</span><br><span class="line">    print(f&quot;测试3: &#123;nums3&#125;&quot;)  # 应该输出 [1, 2, 3, 4, 5]</span><br><span class="line">    </span><br><span class="line">    # 测试用例4</span><br><span class="line">    nums4 = [0, 0, 0, 1, 2]</span><br><span class="line">    moveZeroes(nums4)</span><br><span class="line">    print(f&quot;测试4: &#123;nums4&#125;&quot;)  # 应该输出 [1, 2, 0, 0, 0]</span><br><span class="line"></span><br><span class="line"># 运行测试</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    test_moveZeroes()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>法算day3</title>
      <link href="/lief/%E6%B3%95%E7%AE%97day3/"/>
      <url>/lief/%E6%B3%95%E7%AE%97day3/</url>
      
        <content type="html"><![CDATA[<h1 id="最长序列"><a href="#最长序列" class="headerlink" title="最长序列"></a>最长序列</h1><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。<br>请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p><p>示例 1：<br>输入：nums &#x3D; [100,4,200,1,3,2]<br>输出：4<br>解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</p><p>示例 2：<br>输入：nums &#x3D; [0,3,7,2,5,8,4,6,0,1]<br>输出：9</p><p>示例 3：<br>输入：nums &#x3D; [1,0,1,2]<br>输出：3</p><p>提示：<br>0 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109</p><h3 id="tip"><a href="#tip" class="headerlink" title="tip"></a>tip</h3><table><thead><tr><th align="center">特性</th><th align="center">HashSet<Integer></th><th align="center">HashMap&lt;Integer, Integer&gt;</th></tr></thead><tbody><tr><td align="center">本质</td><td align="center">只存“值”的集合</td><td align="center">存“键值对”的映射表</td></tr><tr><td align="center">泛型参数</td><td align="center"><E>（元素类型）</td><td align="center">&lt;K, V&gt;（键类型，值类型）</td></tr><tr><td align="center">能否重复</td><td align="center">元素不能重复</td><td align="center">键不能重复，值可以重复</td></tr><tr><td align="center">查询方式</td><td align="center">contains(value) 判断值是否存在</td><td align="center">get(key) 用键取值</td></tr><tr><td align="center">常用方法</td><td align="center">add(e)、remove(e)、contains(e)</td><td align="center">put(k,v)、get(k)、remove(k)</td></tr></tbody></table><h3 id="java版"><a href="#java版" class="headerlink" title="java版"></a>java版</h3><h4 id="方法一：先把所有数字放进“快速查找表”HashSet，然后只从每个“序列开头”往后数，数完更新最长值，保证每个数字最多被看两遍，时间复杂度就是-O-n-。"><a href="#方法一：先把所有数字放进“快速查找表”HashSet，然后只从每个“序列开头”往后数，数完更新最长值，保证每个数字最多被看两遍，时间复杂度就是-O-n-。" class="headerlink" title="方法一：先把所有数字放进“快速查找表”HashSet，然后只从每个“序列开头”往后数，数完更新最长值，保证每个数字最多被看两遍，时间复杂度就是 O(n)。"></a>方法一：先把所有数字放进“快速查找表”HashSet，然后只从每个“序列开头”往后数，数完更新最长值，保证每个数字最多被看两遍，时间复杂度就是 O(n)。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public int longestConsecutive(int[] nums) &#123;</span><br><span class="line">        // 如果数组是空的，直接返回 0，啥也不用干</span><br><span class="line">        if (nums == null || nums.length == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 1. 先把所有数字“丢进”一个 HashSet，相当于建立一个“快速查找表”</span><br><span class="line">        Set&lt;Integer&gt; numSet = new HashSet&lt;&gt;();</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            numSet.add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int maxLength = 0;   // 用来记录全局最长连续序列的长度</span><br><span class="line"></span><br><span class="line">        // 2. 开始遍历数组</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            // 2.1 只有当“num-1”不在集合里时，num 才是一个连续序列的“开头”</span><br><span class="line">            if (!numSet.contains(num - 1)) &#123;</span><br><span class="line">                int currentNum = num;    // 从当前这个“开头”出发</span><br><span class="line">                int currentLength = 1;   // 目前这个序列长度先算 1（只有自己）</span><br><span class="line"></span><br><span class="line">                // 2.2 不断看“下一个数字”在不在集合里，如果在就继续往后数</span><br><span class="line">                while (numSet.contains(currentNum + 1)) &#123;</span><br><span class="line">                    currentNum++;      // 挪到下一个数字</span><br><span class="line">                    currentLength++;   // 序列长度 +1</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 2.3 这一整条序列数完了，更新全局最大值</span><br><span class="line">                maxLength = Math.max(maxLength, currentLength);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 3. 最后把最长长度返回即可</span><br><span class="line">        return maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ 说明：</p><ol><li>时间复杂度<br> 建集合：for num in nums 一次遍历，O(n)。<br> 再遍历数组：看似两层循环，但每个数字最多被“往后数”一次；<br> 一旦某个数字被当作序列内部元素（非起点）时，根本不会进入内层 while。<br> 所以总工作量 ≤ 2n，仍属 O(n)。</li><li>空间复杂度<br> 额外开了一个集合 num_set，最坏存下所有元素，大小 n，因此 O(n)。<br>总结：<br> 算法只多占一份“哈希表”内存，却换来线性时间，是典型“空间换时间”的套路。</li></ol><h3 id="python版"><a href="#python版" class="headerlink" title="python版"></a>python版</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">from typing import List</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def longestConsecutive(self, nums: List[int]) -&gt; int:</span><br><span class="line">        # 1. 空数组直接返回 0</span><br><span class="line">        if not nums:</span><br><span class="line">            return 0</span><br><span class="line"></span><br><span class="line">        # 2. 把所有数字放进集合，方便 O(1) 查找</span><br><span class="line">        num_set = set(nums)</span><br><span class="line"></span><br><span class="line">        max_length = 0  # 全局最长连续序列长度</span><br><span class="line"></span><br><span class="line">        # 3. 遍历每个数字</span><br><span class="line">        for num in nums:</span><br><span class="line">            # 3.1 只有当 num-1 不在集合里时，num 才是一个序列的“开头”</span><br><span class="line">            if num - 1 not in num_set:</span><br><span class="line">                current_num = num      # 从当前数字开始往后数</span><br><span class="line">                current_length = 1     # 目前序列长度至少为 1（自己）</span><br><span class="line"></span><br><span class="line">                # 3.2 不断看“下一个数字”是否存在</span><br><span class="line">                while current_num + 1 in num_set:</span><br><span class="line">                    current_num += 1   # 挪到下一个数字</span><br><span class="line">                    current_length += 1  # 长度 +1</span><br><span class="line"></span><br><span class="line">                # 3.3 更新全局最大值</span><br><span class="line">                max_length = max(max_length, current_length)</span><br><span class="line"></span><br><span class="line">        # 4. 返回最长长度</span><br><span class="line">        return max_length</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 简单测试</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    print(Solution().longestConsecutive([100, 4, 200, 1, 3, 2]))  # 输出 4</span><br><span class="line">    print(Solution().longestConsecutive([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]))  # 输出 9</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>法算day2</title>
      <link href="/lief/%E6%B3%95%E7%AE%97day2/"/>
      <url>/lief/%E6%B3%95%E7%AE%97day2/</url>
      
        <content type="html"><![CDATA[<h1 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a>字母异位词分组</h1><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</p><p>示例 1:<br>输入: strs &#x3D; [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]<br>输出: [[“bat”],[“nat”,”tan”],[“ate”,”eat”,”tea”]]</p><p>解释：<br>在 strs 中没有字符串可以通过重新排列来形成 “bat”。<br>字符串 “nat” 和 “tan” 是字母异位词，因为它们可以重新排列以形成彼此。<br>字符串 “ate” ，”eat” 和 “tea” 是字母异位词，因为它们可以重新排列以形成彼此。</p><p>示例 2:<br>输入: strs &#x3D; [“”]<br>输出: [[“”]]</p><p>示例 3:<br>输入: strs &#x3D; [“a”]<br>输出: [[“a”]]</p><p>提示：<br>1 &lt;&#x3D; strs.length &lt;&#x3D; 104<br>0 &lt;&#x3D; strs[i].length &lt;&#x3D; 100<br>strs[i] 仅包含小写字母</p><h3 id="java版"><a href="#java版" class="headerlink" title="java版"></a>java版</h3><h4 id="方法一：排序签名，即对字符排序"><a href="#方法一：排序签名，即对字符排序" class="headerlink" title="方法一：排序签名，即对字符排序"></a>方法一：排序签名，即对字符排序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 主类：GroupAnagrams</span><br><span class="line"> * 功能：把一堆字符串中所有“字母异位词”自动归到同一组。</span><br><span class="line"> * 字母异位词：字母相同、出现次数相同，只是顺序不同，如 &quot;eat&quot; 和 &quot;tea&quot;。</span><br><span class="line"> */</span><br><span class="line">public class GroupAnagrams &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 唯一公开接口：groupAnagrams</span><br><span class="line">     * 参数：strs – 待分组的原始字符串数组，可能为空、可能含空串</span><br><span class="line">     * 返回：List&lt;List&lt;String&gt;&gt; – 每一层 List 就是一个分组，组内字符串互为异位词</span><br><span class="line">     */</span><br><span class="line">    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        /* ---------- 1. 边界保护 ---------- */</span><br><span class="line">        if (strs == null || strs.length == 0) &#123;</span><br><span class="line">            // 外面传进来的是空指针或空数组，直接返回“空列表”，避免后面代码抛异常</span><br><span class="line">            return new ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* ---------- 2. 准备哈希表 ---------- */</span><br><span class="line">        // key（String）：某个“签名”，所有互为异位词的字符串都会生成完全相同的签名</span><br><span class="line">        // value（List&lt;String&gt;）：属于这个签名的所有原始字符串</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        /* ---------- 3. 遍历每个字符串 ---------- */</span><br><span class="line">        for (String s : strs) &#123;                 // s 可能是 &quot;&quot;，也可能是 &quot;aabbCc&quot; 等任意小写字母</span><br><span class="line">            /* 3.1 生成签名：把字符排序后得到的字符串就是签名</span><br><span class="line">               原因：异位词排序后必然得到同一串字符，例如 &quot;eat&quot;、&quot;tea&quot; 排序后都是 &quot;aet&quot; */</span><br><span class="line">            char[] chars = s.toCharArray();     // 把当前字符串拆成字符数组，方便排序</span><br><span class="line">            Arrays.sort(chars);                 // 快速排序，复杂度 O(k log k)，k 为字符串长度</span><br><span class="line">            String key = new String(chars);     // 再把排好序的字符数组拼回字符串，得到签名</span><br><span class="line"></span><br><span class="line">            /* 3.2 把原始字符串挂到对应签名下面</span><br><span class="line">               computeIfAbsent 的意思是：如果 map 里还没有这个签名，就新建一个空 ArrayList 并返回；</span><br><span class="line">               如果已经有，就直接返回原来的 List。无论哪种情况，add(s) 都会把当前字符串放进这个 List */</span><br><span class="line">            map.computeIfAbsent(key, k -&gt; new ArrayList&lt;&gt;()).add(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* ---------- 4. 组装最终结果 ---------- */</span><br><span class="line">        // map.values() 拿到所有分组 List，再套一层 ArrayList 就是题目要的返回格式</span><br><span class="line">        return new ArrayList&lt;&gt;(map.values());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* ---------- 5. 简单自测 ---------- */</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        GroupAnagrams solution = new GroupAnagrams();</span><br><span class="line">        String[] strs = &#123;&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;&#125;;</span><br><span class="line">        // 期望输出：[[eat, tea, ate], [tan, nat], [bat]]（顺序可能不同）</span><br><span class="line">        System.out.println(solution.groupAnagrams(strs));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ 说明：<br>算法复杂度<br>时间：O(n·k log k)，n 为字符串个数，k 为字符串最大长度（排序耗时）。<br>空间：O(n·k)，用于存储 map 与结果。</p><h2 id="代码疑惑点答疑"><a href="#代码疑惑点答疑" class="headerlink" title="代码疑惑点答疑"></a>代码疑惑点答疑</h2><h3 id="疑点一"><a href="#疑点一" class="headerlink" title="疑点一"></a>疑点一</h3><p><code>public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs)</code> 这一长串看起来吓人，其实每个关键字都在“报户口”——告诉你 <strong>谁都能调用、给的是字符串数组、还回来的是两层口袋的字符串</strong>。一句话拆 6 段解释：</p><ol><li><p><code>public</code><br>“大家都能用”。换成 <code>private</code> 就只能类内部自己玩，别人调不到。</p></li><li><p><code>List&lt;List&lt;String&gt;&gt;</code><br>返回类型：两层 List 嵌套。  </p><ul><li>外层 <code>List</code> 的每一项代表 <strong>一个分组</strong>；  </li><li>内层 <code>List&lt;String&gt;</code> 装的是 <strong>该分组里的所有字符串</strong>。<br>为什么用接口 <code>List</code> 而不用具体类？<br>面向接口编程：调用者只关心“它是个列表”，不关心你背后是 <code>ArrayList</code> 还是 <code>LinkedList</code>，给实现留余地。</li></ul></li><li><p><code>groupAnagrams</code><br>方法名，见名知意：把 anagrams（字母异位词）group（分组）。</p></li><li><p><code>(String[] strs)</code><br>形参：一个字符串数组，里面扔进来一堆原始单词，等待被分类。</p></li><li><p>为什么没有 <code>static</code>？<br>需要 <strong>先 new 一个对象</strong> 再调用，这样方法内部可以访问到对象级别的字段（虽然现在没用，但预留扩展）。如果写成 <code>static</code>，就成了工具方法，属于类本身，无法访问实例成员。</p></li><li><p>为什么泛型要写两次 <code>&lt;String&gt;</code>？<br>Java 泛型不支持“裸”嵌套，必须写全。<code>List&lt;List&lt;String&gt;&gt;</code> 读作：一个列表，里面的元素还是“装字符串的列表”。</p></li></ol><p>总结：<br>这句声明就是一份 <strong>方法招牌</strong>——“公开营业，收字符串数组，返分组列表，欢迎来调”。</p><h3 id="疑点二"><a href="#疑点二" class="headerlink" title="疑点二"></a>疑点二</h3><p><code>return new ArrayList&lt;&gt;();</code> 这一行干的事情可以拆成三步看：</p><ol><li><p><strong>new ArrayList&lt;&gt;()</strong><br>在堆上真正创建了一个 <strong>空的</strong> <code>ArrayList</code> 对象（底层数组长度默认 0，第一次 add 时才会扩容）。</p></li><li><p><strong>泛型推断</strong><br>因为方法返回值已经被编译器确定为 <code>List&lt;List&lt;String&gt;&gt;</code>，所以这里的 <code>&lt;&gt;</code> 被自动推断成 <code>ArrayList&lt;List&lt;String&gt;&gt;()</code>；你不用重复写泛型参数。</p></li><li><p><strong>return 出去</strong><br>你拿到手的 <strong>实际上</strong> 是一个：</p><ul><li><strong>空</strong>的、</li><li><strong>可变的</strong>、</li><li><strong>顺序保持的</strong>、</li><li><strong>允许重复元素</strong>的<br><code>ArrayList</code> 实例，只不过对外展现的类型是它的接口 <code>List&lt;List&lt;String&gt;&gt;</code>。</li></ul></li></ol><p>一句话：<br>“别人眼里你只是‘空列表’，本质上就是刚出炉、还没装任何分组的 <code>ArrayList</code> 对象。”</p><h3 id="疑点三"><a href="#疑点三" class="headerlink" title="疑点三"></a>疑点三</h3><p>for (String s : strs) 是 Java 的“增强版 for 循环”（也叫 foreach），它把“索引、边界判断、自增”这些脏活全部藏起来，让你只关心 每个元素本身。<br>逐字拆解：<br>for (<br>循环关键字，开场白。<br>String s<br>循环变量：每次进入循环体，都会把当前拿到的字符串塞进这个局部变量 s 里，类型必须和数组元素一致（这里是 String）。<br>:<br>读作“在……里面”，官方叫“in”。<br>strs<br>要被遍历的 数组或 Iterable 集合，这里是我们传进来的 String[] strs。<br>执行流程（伪代码等价）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; strs.length; i++) &#123;</span><br><span class="line">    String s = strs[i];   // 自动帮你取下标、赋值</span><br><span class="line">    // ↓ 你自己的代码</span><br><span class="line">    ...                   // 这里写对 s 的操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>索引 i 由编译器自动生成，但你 看不见、也用不到。<br>特点<br>只能 从前到后 一趟扫，不能跳着走，也不能反向。<br>不能修改数组长度（不能 add&#x2F;remove），但 可以读取、可以修改元素本身（如果元素是可变对象）。<br>代码更短，少了下标越界风险，可读性高。<br>在本例里：<br>每轮循环 s 依次代表 “eat”、”tea”、”tan”……直到最后一个单词，循环自动结束。<br>你只需要把注意力放在“拿到一个字符串后怎么生成签名、怎么塞进 map”即可，下标那些事编译器全包。</p><h3 id="疑点四"><a href="#疑点四" class="headerlink" title="疑点四"></a>疑点四</h3><p>把这一行拆成“两句话”看，就秒懂：<br>map.computeIfAbsent(key, k -&gt; new ArrayList&lt;&gt;())<br>意思是：<br>“如果 map 里还没有这个 key，就新建一个 空 ArrayList 并放进 map，然后把这个 List 返回；<br>如果已经存在，就直接把原来那个 List 返回。”<br>.add(s)<br>拿到上一步返回的 List（不管是刚新建的还是原来就有的），把当前字符串 s 塞进去。<br>所以整行等价于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = map.get(key);     // 先查</span><br><span class="line">if (list == null) &#123;                   // 没有就建</span><br><span class="line">    list = new ArrayList&lt;&gt;();</span><br><span class="line">    map.put(key, list);</span><br><span class="line">&#125;</span><br><span class="line">list.add(s);                          // 再装</span><br></pre></td></tr></table></figure><p>只是 computeIfAbsent 把“查-判-建-放”四步一次性做完，并直接返回那个 一定存在的 List，让你立刻能 .add(s)。<br>变量名 k 是 Lambda 的形参，代表 key，这里没用到，起个占位符名字即可。</p><h3 id="重点理解"><a href="#重点理解" class="headerlink" title="重点理解"></a>重点理解</h3><p>下面用<strong>一个完整的字符串</strong>当例子，把<br><code>map.computeIfAbsent(key, k -&gt; new ArrayList&lt;&gt;()).add(s);</code><br>的每一步都“慢放”给你看。</p><p>假设当前字符串 s &#x3D; “tea”</p><ol><li><p>生成签名<br>char[] chars &#x3D; “tea”.toCharArray() → 排序 → {‘a’,’e’,’t’} → key &#x3D; “aet”</p></li><li><p>看 map 里有没有 key&#x3D;”aet”<br>此时 map 还是空的，get(“aet”) 会返回 null。</p></li><li><p>进入 computeIfAbsent<br>因为找不到，于是执行 Lambda：k -&gt; new ArrayList&lt;&gt;()<br>新建一个空 ArrayList，把它放进 map，并把这个 List 返回。<br>此刻内存里变成：<br>map &#x3D; {“aet” → []}   （空列表）</p></li><li><p>返回的 List 立刻 .add(s)<br>[].add(“tea”) → 列表变成 [“tea”]<br>最终 map 是：<br>{“aet” → [“tea”]}</p></li><li><p>下一个循环如果碰到 “eat”<br>签名还是 “aet”，这次 map 里已存在，computeIfAbsent 直接返回原列表 [“tea”]，<br>再 .add(“eat”) → 列表变成 [“tea”, “eat”]，无需再建 ArrayList。</p></li></ol><p>一句话：<br>“第一次来就给你新建个口袋，后面再来同名签名直接往旧口袋里继续扔。”</p><h3 id="python版"><a href="#python版" class="headerlink" title="python版"></a>python版</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">from collections import defaultdict  # 引入一个方便的字典类，后面会解释</span><br><span class="line">from typing import List              # 只是告诉 Python 我们要用 List 做类型提示，不写也能跑</span><br><span class="line"></span><br><span class="line">class Solution:                      # 把所有功能包在一个类里，刷题平台喜欢这种写法</span><br><span class="line">    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:</span><br><span class="line">        # 1. 建一个“有默认值”的字典：当访问一个不存在的 key 时，它会自动先放一个空列表进去</span><br><span class="line">        groups = defaultdict(list)</span><br><span class="line"></span><br><span class="line">        # 2. 逐个看输入的字符串</span><br><span class="line">        for s in strs:</span><br><span class="line">            # 3. 把字符串里的字母按字母表顺序排好，变成“签名”</span><br><span class="line">            #    例如 &quot;tea&quot; -&gt; 排序后变成 &quot;aet&quot;</span><br><span class="line">            key = &#x27;&#x27;.join(sorted(s))</span><br><span class="line"></span><br><span class="line">            # 4. 把原字符串挂到这个签名对应的列表里</span><br><span class="line">            #    同一签名下的所有字符串互为字母异位词</span><br><span class="line">            groups[key].append(s)</span><br><span class="line"></span><br><span class="line">        # 5. 把字典里所有的列表一次性拿出来，就是最终答案</span><br><span class="line">        return list(groups.values())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 下面这段是“自测”代码，只在直接运行本文件时生效</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    print(Solution().groupAnagrams([&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]))</span><br><span class="line">    # 期望输出: [[&#x27;eat&#x27;, &#x27;tea&#x27;, &#x27;ate&#x27;], [&#x27;tan&#x27;, &#x27;nat&#x27;], [&#x27;bat&#x27;]]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>法算day1</title>
      <link href="/lief/%E6%B3%95%E7%AE%97day1/"/>
      <url>/lief/%E6%B3%95%E7%AE%97day1/</url>
      
        <content type="html"><![CDATA[<h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。<br>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。<br>你可以按任意顺序返回答案。</p><p>示例 1：</p><p>输入：nums &#x3D; [2,7,11,15], target &#x3D; 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。<br>示例 2：</p><p>输入：nums &#x3D; [3,2,4], target &#x3D; 6<br>输出：[1,2]<br>示例 3：</p><p>输入：nums &#x3D; [3,3], target &#x3D; 6<br>输出：[0,1]</p><h3 id="java版"><a href="#java版" class="headerlink" title="java版"></a>java版</h3><h4 id="方法一：使用了哈希表（HashMap）来高效地查找两个数的和是否等于目标值"><a href="#方法一：使用了哈希表（HashMap）来高效地查找两个数的和是否等于目标值" class="headerlink" title="方法一：使用了哈希表（HashMap）来高效地查找两个数的和是否等于目标值"></a>方法一：使用了哈希表（HashMap）来高效地查找两个数的和是否等于目标值</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashMap;</span><br><span class="line"></span><br><span class="line">public class TwoSum &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        // 1. 先准备一本“字典”，名字叫 map</span><br><span class="line">    //    左边 key 存“数值”，右边 value 存“这个数值的下标”</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    // 2. 从头到尾扫一遍数组</span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">        // 3. 我想找的“另一半”是多少？</span><br><span class="line">        //    如果 target 是 9，当前数是 2，那我就要找 7</span><br><span class="line">        int need = target - nums[i];</span><br><span class="line"></span><br><span class="line">        // 4. 翻字典看看：之前有没有出现过 7？</span><br><span class="line">        //    如果出现过，它就记录在 map 里，直接拿到它的下标</span><br><span class="line">        if (map.containsKey(need)) &#123;</span><br><span class="line">            // 5. 找到了！把“之前那个数的下标”和“现在这个数字的下标”一起返回</span><br><span class="line">            return new int[]&#123;map.get(need), i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 6. 如果字典里没有 7，就把当前的“数-下标”写进字典</span><br><span class="line">        //    这样后面遇到 7 时就能查到今天的 2 了</span><br><span class="line">        map.put(nums[i], i);//将这对&#x27;值-下标&#x27;存入字典中,数组里的元素被逐步存入了 map。</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        // 题目保证有解，这里只是为了代码能通过编译</span><br><span class="line">        throw new IllegalArgumentException(&quot;No two sum solution&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 简单测试</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TwoSum solution = new TwoSum();</span><br><span class="line">        int[] nums = &#123;2, 7, 11, 15&#125;;</span><br><span class="line">        int target = 9;</span><br><span class="line">        int[] result = solution.twoSum(nums, target);</span><br><span class="line">        System.out.println(&quot;[&quot; + result[0] + &quot;, &quot; + result[1] + &quot;]&quot;);  // 预期输出 [0, 1]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>✅ 说明：<br>时间复杂度：O(n)，只需要遍历一次数组。<br>空间复杂度：O(n)，最坏情况下需要存储所有元素。<br>不能重复使用同一个元素：通过 map 存储的是已经遍历过的元素，确保不会重复使用。<br>如果你需要处理多个解或者有其他限制条件，也可以进一步扩展这个逻辑。</p><h4 id="方法二：暴力枚举——-数据量极小（n-≤-200）时图省事"><a href="#方法二：暴力枚举——-数据量极小（n-≤-200）时图省事" class="headerlink" title="方法二：暴力枚举—— 数据量极小（n ≤ 200）时图省事"></a>方法二：暴力枚举—— 数据量极小（n ≤ 200）时图省事</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public int[] twoSum_brute(int[] nums, int target) &#123;</span><br><span class="line">    for (int i = 0; i &lt; nums.length - 1; i++)</span><br><span class="line">        for (int j = i + 1; j &lt; nums.length; j++)</span><br><span class="line">            if (nums[i] + nums[j] == target)</span><br><span class="line">                return new int[]&#123;i, j&#125;;</span><br><span class="line">    throw new IllegalArgumentException(&quot;No solution&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>✅ 说明：<br>时间 O(n²) 空间 O(1)</p><h3 id="python版"><a href="#python版" class="headerlink" title="python版"></a>python版</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">from typing import List</span><br><span class="line"></span><br><span class="line"># 解法 1：暴力枚举</span><br><span class="line">def two_sum_bruteforce(nums: List[int], target: int) -&gt; List[int]:</span><br><span class="line">    n = len(nums)</span><br><span class="line">    for i in range(n):</span><br><span class="line">        for j in range(i + 1, n):</span><br><span class="line">            if nums[i] + nums[j] == target:</span><br><span class="line">                return [i, j]</span><br><span class="line">    return []   # 题目保证有解，这里不会执行</span><br><span class="line"></span><br><span class="line"># 解法 2：哈希表一次遍历</span><br><span class="line">def two_sum(nums: List[int], target: int) -&gt; List[int]:</span><br><span class="line">    seen = &#123;&#125;                       # 值 -&gt; 下标</span><br><span class="line">    for j, num in enumerate(nums):  # 当前下标 j</span><br><span class="line">        need = target - num</span><br><span class="line">        if need in seen:            # 之前已经遇到过符合条件的另一半</span><br><span class="line">            return [seen[need], j]</span><br><span class="line">        seen[num] = j               # 记录值和下标</span><br><span class="line">    return []                       # 题目保证有解，这里不会执行</span><br><span class="line"></span><br><span class="line"># 简单测试</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    nums = [2, 7, 11, 15]</span><br><span class="line">    target = 9</span><br><span class="line">    print(two_sum(nums, target))          # 输出: [0, 1]</span><br><span class="line">    print(two_sum_bruteforce(nums, target))  # 输出: [0, 1]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot学习日志</title>
      <link href="/lief/Springboot%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/lief/Springboot%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot入门-SpringBoot-hello-LEE"><a href="#SpringBoot入门-SpringBoot-hello-LEE" class="headerlink" title="SpringBoot入门 - SpringBoot hello LEE"></a>SpringBoot入门 - SpringBoot hello LEE</h1><h3 id="通过-IDE-集成工具创建"><a href="#通过-IDE-集成工具创建" class="headerlink" title="通过 IDE 集成工具创建"></a>通过 IDE 集成工具创建</h3><p>IntelliJ IDEA：<br>File → New → Project<br>选择 “Spring Boot”<br>配置项目信息和依赖项</p><img src="/lief/Springboot%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/1.png" class=""><img src="/lief/Springboot%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/2.png" class=""><p>点击create，完成创建</p><h3 id="修改Sb1Application代码即可"><a href="#修改Sb1Application代码即可" class="headerlink" title="修改Sb1Application代码即可"></a>修改Sb1Application代码即可</h3><img src="/lief/Springboot%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/4.png" class=""><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.example.sb1;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.http.HttpStatus;</span><br><span class="line">import org.springframework.http.ResponseEntity;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">// Spring Boot应用程序的主类，包含启动方法和REST控制器</span><br><span class="line">@SpringBootApplication</span><br><span class="line">@RestController</span><br><span class="line"></span><br><span class="line">public class Sb1Application &#123;</span><br><span class="line"></span><br><span class="line">    // 程序入口点，启动Spring Boot应用</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Sb1Application.class, args);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    // 处理GET请求的/hello端点，返回问候信息</span><br><span class="line">    @GetMapping(&quot;/hello&quot;)</span><br><span class="line">    public ResponseEntity&lt;String&gt; hello() &#123;</span><br><span class="line">        // 返回包含&quot;hello LEE&quot;消息和HTTP 200状态的响应</span><br><span class="line">        return new ResponseEntity&lt;&gt;(&quot;hello LEE&quot;, HttpStatus.OK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行后地址栏输入http-localhost-8080-hello"><a href="#运行后地址栏输入http-localhost-8080-hello" class="headerlink" title="运行后地址栏输入http://localhost:8080/hello"></a>运行后地址栏输入<a href="http://localhost:8080/hello">http://localhost:8080/hello</a></h2><img src="/lief/Springboot%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/3.png" class="">]]></content>
      
      
      
        <tags>
            
            <tag> 学习日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>终不似 少年游</title>
      <link href="/lief/%E7%BB%88%E4%B8%8D%E4%BC%BC-%E5%B0%91%E5%B9%B4%E6%B8%B8/"/>
      <url>/lief/%E7%BB%88%E4%B8%8D%E4%BC%BC-%E5%B0%91%E5%B9%B4%E6%B8%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="高达有感"><a href="#高达有感" class="headerlink" title="高达有感"></a>高达有感</h1><p>不知道，我是何时听到过高达这两个字，那时候似乎见过，给人的印象就是很帅，那时候还小，没钱O(∩_∩)O哈哈~。<br>就在今年偶然一次刷到视频，就打算买一个玩玩，当然是ko。以下是这几个月陆陆续续拼的，记录一下吧！</p><h2 id="樱花自由"><a href="#樱花自由" class="headerlink" title="樱花自由"></a>樱花自由</h2><p>jms的，第一次把头部拼出来，那感觉，和印象中的一样帅！那时很激动，<br>不过第一次拼并不会摆姿势，网友调侃说，和wjk的一样，当时没有听懂，还特地搜了一下。<br><img src="https://eedbdc0.webp.li/docs/1755100362543.jpg"></p><h2 id="马克兔"><a href="#马克兔" class="headerlink" title="马克兔"></a>马克兔</h2><p>第一个拼完，有点意犹未尽，又买了一个，还是jms的；<br>因为刚入这个圈，不知道买这个还要检查板件，拼到一半才发现少一个零件，还好商家是好人，给我免费补发了，给商家点赞！<br><img src="https://eedbdc0.webp.li/docs/1755101070723.jpg"></p><h2 id="飞升自由"><a href="#飞升自由" class="headerlink" title="飞升自由"></a>飞升自由</h2><p>就在这段时间，看别人测评视频，看了好久，最终选了这个，不幸的是，再剪面罩时，没剪好，导致有点毁容，<br>我记得当时那么点大的东西，我粘了好久，才让脸还算看的过去。<br><img src="https://eedbdc0.webp.li/docs/1755101204947.jpg"></p><h2 id="RX-78-元祖"><a href="#RX-78-元祖" class="headerlink" title="RX-78 元祖"></a>RX-78 元祖</h2><p>刚开始入圈的时候，觉得元祖的帅有点欣赏不来，没想到后面不知道咋回事，就是觉得很帅，而且还是带骨架的，没玩过，想试试！<br><img src="https://eedbdc0.webp.li/docs/1755101248840.jpg"></p><h2 id="强袭自由"><a href="#强袭自由" class="headerlink" title="强袭自由"></a>强袭自由</h2><p>这个是我买过最贵的了，虽然只是个ko，最强最帅，某次价格合适就入手了，真的很帅哈哈哈。<br><img src="https://eedbdc0.webp.li/docs/1755101323439.jpg"></p><h2 id="RX-93-v高达"><a href="#RX-93-v高达" class="headerlink" title="RX-93 v高达"></a>RX-93 v高达</h2><p>牛高达，不得不说，在上面这段时间，没刷到过；某次看到，真帅，这比例简直了，太帅了，心动不已；<br>奈何正版价格太贵了，当时想着等等ko吧，出来必买，你看，许愿成功；感谢龍哥！<br><img src="https://eedbdc0.webp.li/docs/1755101667372.jpg"><br><img src="https://eedbdc0.webp.li/docs/1755101693952.jpg"></p><h1 id="一些合照"><a href="#一些合照" class="headerlink" title="一些合照"></a>一些合照</h1><p>咔咔咔，一顿猛拍！其实身边已经没人可以分享了；<br>但是dy会大数据推送，我经常评论分享，那种互相有回应的感觉真棒！没想到是胶佬给的，感动！<br>此刻的心情是应该很长一段时间不会再拼了，我也不知道为啥，可能自己不小了吧？<br>现在的时间是2025年12点56分！胶佬们，早点休息，爱护自己哦！<br><img src="https://eedbdc0.webp.li/docs/1755101763293.jpg"><br><img src="https://eedbdc0.webp.li/docs/1755101787183.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 生活日常 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图床搭建(Cloudflare R2)</title>
      <link href="/lief/%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA-Cloudflare-R2/"/>
      <url>/lief/%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA-Cloudflare-R2/</url>
      
        <content type="html"><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>本次搭建需用到域名，Cloudflare R2，PicGo</p><h3 id="插曲"><a href="#插曲" class="headerlink" title="插曲"></a>插曲</h3><p>TIP：创作此次blog用到以下指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post 图床搭建&quot;(Cloudflare R2)&quot;</span><br></pre></td></tr></table></figure><h2 id="创建存储桶"><a href="#创建存储桶" class="headerlink" title="创建存储桶"></a>创建存储桶</h2><p>进入Cloudflare，左边栏有R2对象存储，进入创建存储桶。<br><img src="https://eedbdc0.webp.li/docs/1754979785873.png"><br>创建后点击设置，设置自定义域，然后连接域；<br>返回概述，点击创建令牌，权限选对象读和写，其他不用管，直接创建api令牌，显示的画面请复制内容，因为只显示一次。</p><h2 id="连接PicGO"><a href="#连接PicGO" class="headerlink" title="连接PicGO"></a>连接PicGO</h2><p>打开PIcGo 下载插件，直接在插件搜索s3，点击安装；打开图床设置会有下载的插件，根据复制内容填写即可<br><img src="https://eedbdc0.webp.li/docs/1754980061584.png"><br>即创建成功！</p><h3 id="TIP"><a href="#TIP" class="headerlink" title="TIP"></a>TIP</h3><p>本次使用的图片均为图床里的图片。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建日志，持续记录</title>
      <link href="/lief/%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%9C%9D%E5%9C%A3/"/>
      <url>/lief/%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%9C%9D%E5%9C%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h1><p>前提：配置cloudflare，托管域名<br>开发：需安装Node、GIt、VScode(可选)<br>检查：调用cmd，在命令行中输入 node -v 检查版本信息；git，验证安装完毕后，Windows 用户会在开始菜单中看到 Git Bash 等应用</p><h1 id="2-进行开发"><a href="#2-进行开发" class="headerlink" title="2.进行开发"></a>2.进行开发</h1><h2 id="2-1配置Git用户名和邮箱："><a href="#2-1配置Git用户名和邮箱：" class="headerlink" title="2.1配置Git用户名和邮箱："></a>2.1配置Git用户名和邮箱：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;你的用户名&quot;</span><br><span class="line">git config --global user.email &quot;你的邮箱&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过git config -l 验证是否成功</p><h2 id="2-2配置公钥链接github"><a href="#2-2配置公钥链接github" class="headerlink" title="2.2配置公钥链接github"></a>2.2配置公钥链接github</h2><p>生成SSH公钥</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;你的邮箱&quot;</span><br></pre></td></tr></table></figure><p>一路回车生成密钥，进入 .ssh 文件夹复制 id_rsa.pub 公钥内容，配置到 Github 的 SSH 设置中。</p><h3 id="在windows电脑上："><a href="#在windows电脑上：" class="headerlink" title="在windows电脑上："></a>在windows电脑上：</h3><p>打开C盘下用户文件夹下的.ssh的文件夹，会看到以下文件<br>id_rsa 私钥<br>id_rsa.pub 公钥</p><p>找到公钥匙，并复制，打开GitHub开始配置，将 SSH KEY 配置到 GitHub<br>进入github，点击右上角头像 选择settings，进入设置页后选择 SSH and GPG keys，名字随便起，公钥填到Key那一栏</p><p>测试连接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>第一次连接会提示Are you sure you want to continue connecting (yes&#x2F;no&#x2F;[fingerprint])?，输入yes即可</p><img src="/lief/%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%9C%9D%E5%9C%A3/r1.png" class=""><p>插曲：第一次写博客，发现不会插入图片,首先得cmd安装插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-asset-img --save</span><br></pre></td></tr></table></figure><h2 id="2-3创建-GitHub-io-仓库"><a href="#2-3创建-GitHub-io-仓库" class="headerlink" title="2.3创建 GitHub.io 仓库"></a>2.3创建 GitHub.io 仓库</h2><p>点击右上角的 + 按钮，选择新建仓库，命名格式为 &lt;用户名&gt;.github.io，(注意：前缀必须为用户名)选择公开 Public。<br>点击 Creat repository 进行创建即可。  </p><h2 id="2-4初始化Hexo博客"><a href="#2-4初始化Hexo博客" class="headerlink" title="2.4初始化Hexo博客"></a>2.4初始化Hexo博客</h2><p>1.创建文件夹保存博客源码<br>   例如D:&#x2F;Hexo<br>2.安装Hexo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli &amp;&amp; hexo -v</span><br></pre></td></tr></table></figure><p>3.初始化 Hexo 项目安装依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog-demo</span><br><span class="line">cd blog-demo</span><br><span class="line">npm i</span><br></pre></td></tr></table></figure><p>现在你的文件夹会有这些内容</p><img src="/lief/%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%9C%9D%E5%9C%A3/2025-08-11-16-36-29.png" class=""><p>4.启动项目并验证:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo cl ; hexo s</span><br></pre></td></tr></table></figure><p>在终端输出栏的网址<a href="http://localhost:4000/%E8%AE%BF%E9%97%AE%EF%BC%8C%E6%9F%A5%E7%9C%8B%E6%9C%80%E7%BB%88%E6%95%88%E6%9E%9C%E3%80%82">http://localhost:4000/访问，查看最终效果。</a></p><h2 id="2-5将静态博客挂载到-GitHub-Pages"><a href="#2-5将静态博客挂载到-GitHub-Pages" class="headerlink" title="2.5将静态博客挂载到 GitHub Pages"></a>2.5将静态博客挂载到 GitHub Pages</h2><p>1.修改 _config.yml 文件，配置 repository 为你的 GitHub 地址，分支改为 main：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:你的用户名/你的用户名.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><img src="/lief/%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%9C%9D%E5%9C%A3/2025-08-11-16-47-45.png" class=""><p>2.安装 hexo-deployer-git：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>3.部署到 GitHub</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Git BASH终端,必须是管理员身份，cmd同理</span><br><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy  </span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line"></span><br><span class="line">// VSCODE终端</span><br><span class="line">hexo cl; hexo g; hexo d</span><br></pre></td></tr></table></figure><img src="/lief/%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%9C%9D%E5%9C%A3/2025-08-11-16-51-15.png" class=""><p>访问 https:&#x2F;&#x2F;&lt;用户名&gt;.github.io&#x2F; 以查看博客。</p><h2 id="2-6将静态博客挂载到-Cloudflare-Pages"><a href="#2-6将静态博客挂载到-Cloudflare-Pages" class="headerlink" title="2.6将静态博客挂载到 Cloudflare Pages"></a>2.6将静态博客挂载到 Cloudflare Pages</h2><p>1.通过 Cloudflare Pages 连接 Git 仓库。<br>2。选择刚刚的存储库，点击保存并部署。<br>3.部署成功后，访问 Cloudflare 提供的链接。<br>如有自定义域名，可以在 Cloudflare Pages 中绑定。没有建议去申请，这样博客就不被墙了。<br>4.至此，你就可以用自己的域名访问自己的博客了</p><h1 id="3-安装主题"><a href="#3-安装主题" class="headerlink" title="3.安装主题"></a>3.安装主题</h1><p>HEXO主题有很多，<a href="https://hexo.io/themes/">点击跳转</a>可以选择自己喜欢的进行安装，本次选的是anzhiyu的</p><h2 id="3-1-Git安装"><a href="#3-1-Git安装" class="headerlink" title="3.1 Git安装"></a>3.1 Git安装</h2><p>在博客根目录里安装最新版【推荐】：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b main https://github.com/anzhiyu-c/hexo-theme-anzhiyu.git themes/anzhiyu</span><br></pre></td></tr></table></figure><h2 id="3-2安装-Pug-和-Stylus-渲染插件"><a href="#3-2安装-Pug-和-Stylus-渲染插件" class="headerlink" title="3.2安装 Pug 和 Stylus 渲染插件"></a>3.2安装 Pug 和 Stylus 渲染插件</h2><p>运行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><p>使用主题，修改 Hexo 配置文件 _config.yml，将主题theme改为 anzhiyu。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: anzhiyu</span><br></pre></td></tr></table></figure><h2 id="3-3覆盖配置"><a href="#3-3覆盖配置" class="headerlink" title="3.3覆盖配置"></a>3.3覆盖配置</h2><p>覆盖配置可将主题配置放置在 anzhiyu 目录之外，避免在更新主题时丢失自定义的配置。通过 Npm 安装主题的用户可忽略，其他用户建议学习使用。Windows 用户复制 &#x2F;themes&#x2F;anzhiyu&#x2F;_config.yml 到 Hexo 根目录，并重命名为 _config.anzhiyu.yml。后续修改主题配置只需更新 _config.anzhiyu.yml。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>_config.anzhiyu.yml 中的配置优先级高于 _config.yml。<br>每次更新主题时可能存在配置变更，请查看更新说明，并手动同步修改 _config.anzhiyu.yml。<br>可通过 hexo g –debug 查看覆盖配置是否生效。<br>若要将某些配置覆盖为空，注意不要删除主键。</p><h2 id="3-4主题部署就完成了！别忘了推送更新上线"><a href="#3-4主题部署就完成了！别忘了推送更新上线" class="headerlink" title="3.4主题部署就完成了！别忘了推送更新上线"></a>3.4主题部署就完成了！别忘了推送更新上线</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//本地预览</span><br><span class="line">hexo cl; hexo s</span><br><span class="line">//推送更新上线</span><br><span class="line">hexo cl; hexo g; hexo d</span><br></pre></td></tr></table></figure><h1 id="4-博客自定义功能开发"><a href="#4-博客自定义功能开发" class="headerlink" title="4.博客自定义功能开发"></a>4.博客自定义功能开发</h1><h2 id="4-1生成标签页和分类页"><a href="#4-1生成标签页和分类页" class="headerlink" title="4.1生成标签页和分类页"></a>4.1生成标签页和分类页</h2><p>生成标签页：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure><p>找到 source&#x2F;tags&#x2F;index.md 文件，添加 type: “tags”：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2024-07-05 03:36:02</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">comments: false</span><br><span class="line">top_img: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>生成分类页：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure><p>找到 source&#x2F;categories&#x2F;index.md 文件，添加 type: “categories”：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2024-10-22 03:36:48</span><br><span class="line">aside: false</span><br><span class="line">top_img: false</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h2 id="4-2配置文章模版"><a href="#4-2配置文章模版" class="headerlink" title="4.2配置文章模版"></a>4.2配置文章模版</h2><p>&#x2F;scaffolds 目录下有几个模板文件：</p><p>post.md：新建博文模板<br>page.md：新建标签页模板</p><h3 id="post-md-模板示例"><a href="#post-md-模板示例" class="headerlink" title="post.md 模板示例"></a>post.md 模板示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125; #【必需】页面标题</span><br><span class="line">date: #【必需】页面创建日期</span><br><span class="line">updated: #【可选】页面更新日期</span><br><span class="line">tags: #【可选】文章标签</span><br><span class="line">categories: #【可选】文章分类</span><br><span class="line">keywords: #【可选】文章关键字</span><br><span class="line">description: #【可选】文章描述</span><br><span class="line">top: # 1 置顶</span><br><span class="line">top_img: #【可选】文章顶部图片</span><br><span class="line">comments: #【可选】显示文章评论模块(默认 true)</span><br><span class="line">cover: https://img.090227.xyz/file/ae62475a131f3734a201c.png #【可选】文章缩略图</span><br><span class="line">toc: #【可选】显示文章 TOC</span><br><span class="line">toc_number: #【可选】显示 toc_number</span><br><span class="line">toc_style_simple: #【可选】显示 toc 简洁模式</span><br><span class="line">copyright: #【可选】显示文章版权模块</span><br><span class="line">copyright_author: #【可选】文章版权作者</span><br><span class="line">copyright_author_href: #【可选】作者链接</span><br><span class="line">copyright_url: #【可选】版权链接</span><br><span class="line">copyright_info: #【可选】版权声明文字</span><br><span class="line">mathjax: #【可选】显示 mathjax</span><br><span class="line">katex: #【可选】显示 katex</span><br><span class="line">aplayer: #【可选】加载 aplayer 的 js 和 css</span><br><span class="line">highlight_shrink: #【可选】配置代码框是否展开</span><br><span class="line">aside: #【可选】显示侧边栏 (默认 true)</span><br><span class="line">swiper_index: 10 #【可选】首页轮播图配置</span><br><span class="line">top_group_index: 10 #【可选】首页右侧卡片组配置</span><br><span class="line">ai: #【可选】文章 ai 摘要</span><br><span class="line">background: &quot;#fff&quot; #【可选】文章主色</span><br><span class="line">---</span><br><span class="line">&lt;div class=&quot;video-container&quot;&gt;[视频内嵌代码]&lt;/div&gt;</span><br><span class="line">&lt;style&gt;.video-container &#123; position: relative; padding-top: 56.25%; &#125; .video-container iframe &#123; position: absolute; top: 0; left: 0; width: 100%; height: 100%; &#125;&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="page-md-模板示例"><a href="#page-md-模板示例" class="headerlink" title="page.md 模板示例"></a>page.md 模板示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125; #【必需】页面标题</span><br><span class="line">date: #【必需】页面创建日期</span><br><span class="line">type: #【必需】标签、分类等</span><br><span class="line">updated: #【可选】页面更新日期</span><br><span class="line">comments: #【可选】显示页面评论模块</span><br><span class="line">description: #【可选】页面描述</span><br><span class="line">keywords: #【可选】页面关键字</span><br><span class="line">top_img: https://img.090227.xyz/file/ae62475a131f3734a201c.png #【可选】页面顶部图片</span><br><span class="line">mathjax: #【可选】显示 mathjax</span><br><span class="line">katex: #【可选】显示 katex</span><br><span class="line">aside: #【可选】显示侧边栏 (默认 true)</span><br><span class="line">aplayer: #【可选】加载 aplayer 的 js 和 css</span><br><span class="line">highlight_shrink: #【可选】配置代码框是否展开</span><br><span class="line">top_single_background: #【可选】部分页面的顶部模块背景图片</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h2 id="4-3相关插件"><a href="#4-3相关插件" class="headerlink" title="4.3相关插件"></a>4.3相关插件</h2><h3 id="安装本地搜索插件"><a href="#安装本地搜索插件" class="headerlink" title="安装本地搜索插件"></a>安装本地搜索插件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><p>在配置文件(_config.xxx.yml)中添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  preload: false</span><br><span class="line">  CDN:</span><br></pre></td></tr></table></figure><h3 id="安装文章置顶插件"><a href="#安装文章置顶插件" class="headerlink" title="安装文章置顶插件"></a>安装文章置顶插件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-topindex --save</span><br></pre></td></tr></table></figure><p>在需要置顶的文章中添加 top 参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top: 1</span><br></pre></td></tr></table></figure><p>如果存在多个置顶文章，top 后的参数越大，越靠前。</p><h3 id="安装文章中可插入图片插件"><a href="#安装文章中可插入图片插件" class="headerlink" title="安装文章中可插入图片插件"></a>安装文章中可插入图片插件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-asset-img --save</span><br></pre></td></tr></table></figure><h3 id="安装字数统计插件"><a href="#安装字数统计插件" class="headerlink" title="安装字数统计插件"></a>安装字数统计插件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure><h2 id="4-4评论系统搭建"><a href="#4-4评论系统搭建" class="headerlink" title="4.4评论系统搭建"></a>4.4评论系统搭建</h2><p>如果你想在某个网页或者文章页中使用Valine，请参照以下步骤配置</p><h3 id="获取AppID和AppKey"><a href="#获取AppID和AppKey" class="headerlink" title="获取AppID和AppKey"></a>获取AppID和AppKey</h3><p>1.请先登录或<a href="https://console.leancloud.cn/register">注册</a> LeanCloud, 进入控制台后点击左上角创建应用<br>2.应用创建好以后，进入刚刚创建的应用，选择左边的设置&gt;应用凭证，然后就能看到你的AppID和AppKey了,填入代码中即可</p><h3 id="安装valine插件"><a href="#安装valine插件" class="headerlink" title="安装valine插件"></a>安装valine插件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install valine --save</span><br></pre></td></tr></table></figure><h1 id="5-博客使用"><a href="#5-博客使用" class="headerlink" title="5.博客使用"></a>5.博客使用</h1><p>新建博文命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new 这是一篇新的博文</span><br></pre></td></tr></table></figure><p>部署上线</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//本地预览</span><br><span class="line">hexo cl; hexo s</span><br><span class="line">//推送更新上线</span><br><span class="line">hexo cl; hexo g; hexo d</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在心里种花，人生才不会荒芜。</title>
      <link href="/lief/%E5%9C%A8%E5%BF%83%E9%87%8C%E7%A7%8D%E8%8A%B1%EF%BC%8C%E4%BA%BA%E7%94%9F%E6%89%8D%E4%B8%8D%E4%BC%9A%E8%8D%92%E8%8A%9C%E3%80%82/"/>
      <url>/lief/%E5%9C%A8%E5%BF%83%E9%87%8C%E7%A7%8D%E8%8A%B1%EF%BC%8C%E4%BA%BA%E7%94%9F%E6%89%8D%E4%B8%8D%E4%BC%9A%E8%8D%92%E8%8A%9C%E3%80%82/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 我想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面朝大海，春暖花开！</title>
      <link href="/lief/%E9%9D%A2%E6%9C%9D%E5%A4%A7%E6%B5%B7%EF%BC%8C%E6%98%A5%E6%9A%96%E8%8A%B1%E5%BC%80%EF%BC%81/"/>
      <url>/lief/%E9%9D%A2%E6%9C%9D%E5%A4%A7%E6%B5%B7%EF%BC%8C%E6%98%A5%E6%9A%96%E8%8A%B1%E5%BC%80%EF%BC%81/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 我想 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
